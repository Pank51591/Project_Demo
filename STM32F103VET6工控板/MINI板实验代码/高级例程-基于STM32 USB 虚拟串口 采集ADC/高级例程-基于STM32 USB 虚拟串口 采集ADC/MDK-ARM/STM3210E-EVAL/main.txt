; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\STM3210E-EVAL\main.o --depend=.\STM3210E-EVAL\main.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\inc -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Utilities\STM32_EVAL -I..\Utilities\STM32_EVAL\Common -I..\Utilities\STM32_EVAL\STM3210E_EVAL -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL ..\src\main.c]
                          THUMB

                          AREA ||i.ADC_Configuration||, CODE, READONLY, ALIGN=2

                  ADC_Configuration PROC
;;;77     */
;;;78     static void ADC_Configuration(void)
000000  b500              PUSH     {lr}
;;;79     {
000002  b087              SUB      sp,sp,#0x1c
;;;80     	GPIO_InitTypeDef GPIO_InitStructure;
;;;81     	ADC_InitTypeDef ADC_InitStructure;
;;;82     	volatile u16 ADCConvertedValue;
;;;83     
;;;84         /* 使能 ADC1 and GPIOC clock */
;;;85     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOC| RCC_APB2Periph_GPIOB, ENABLE);
000004  2101              MOVS     r1,#1
000006  f44f7006          MOV      r0,#0x218
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;86     	RCC_ADCCLKConfig(RCC_PCLK2_Div6);              //72M/6=12,ADC最大时间不能超过14M
00000e  f44f4000          MOV      r0,#0x8000
000012  f7fffffe          BL       RCC_ADCCLKConfig
;;;87     
;;;88     	
;;;89      
;;;90       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14;	
000016  f44f40e0          MOV      r0,#0x7000
00001a  f8ad0018          STRH     r0,[sp,#0x18]
;;;91       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;       
00001e  2010              MOVS     r0,#0x10
000020  f88d001b          STRB     r0,[sp,#0x1b]
;;;92       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
000026  f88d001a          STRB     r0,[sp,#0x1a]
;;;93       GPIO_Init(GPIOB, &GPIO_InitStructure);  //初始化PB端口
00002a  a906              ADD      r1,sp,#0x18
00002c  4822              LDR      r0,|L1.184|
00002e  f7fffffe          BL       GPIO_Init
;;;94       GPIO_SetBits(GPIOB, GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14);	 // 关闭所有LED
000032  f44f41e0          MOV      r1,#0x7000
000036  4820              LDR      r0,|L1.184|
000038  f7fffffe          BL       GPIO_SetBits
;;;95     
;;;96     	/* 配置PC0为模拟输入(ADC Channel10) */
;;;97     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
00003c  2001              MOVS     r0,#1
00003e  f8ad0018          STRH     r0,[sp,#0x18]
;;;98     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000042  2000              MOVS     r0,#0
000044  f88d001b          STRB     r0,[sp,#0x1b]
;;;99     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000048  a906              ADD      r1,sp,#0x18
00004a  481c              LDR      r0,|L1.188|
00004c  f7fffffe          BL       GPIO_Init
;;;100    
;;;101    	/* 配置ADC1, 不用DMA, 用软件自己触发 */
;;;102    	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;		 //ADC1工作模式:独立模式
000050  2000              MOVS     r0,#0
000052  9001              STR      r0,[sp,#4]
;;;103    	ADC_InitStructure.ADC_ScanConvMode = DISABLE;			 //单通道模式
000054  f88d0008          STRB     r0,[sp,#8]
;;;104    	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;		 //单次转换
000058  f88d0009          STRB     r0,[sp,#9]
;;;105    	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	  //转换由软件而不是外部触发启动
00005c  f44f2060          MOV      r0,#0xe0000
000060  9003              STR      r0,[sp,#0xc]
;;;106    	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;	 //ADC1数据右对齐
000062  2000              MOVS     r0,#0
000064  9004              STR      r0,[sp,#0x10]
;;;107    	ADC_InitStructure.ADC_NbrOfChannel = 1;	   //顺序进行规则转换的ADC通道的数目
000066  2001              MOVS     r0,#1
000068  f88d0014          STRB     r0,[sp,#0x14]
;;;108    	ADC_Init(ADC1, &ADC_InitStructure);		   //根据ADC_InitStruct中指定的参数，初始化外设ADC1的寄存器
00006c  a901              ADD      r1,sp,#4
00006e  4814              LDR      r0,|L1.192|
000070  f7fffffe          BL       ADC_Init
;;;109    
;;;110    	/* ADC1 regular channel10 configuration */
;;;111    	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_239Cycles5);	//ADC1,ADC通道10,规则采样顺序值为1,采样时间为239.5周期
000074  2307              MOVS     r3,#7
000076  2201              MOVS     r2,#1
000078  2100              MOVS     r1,#0
00007a  4811              LDR      r0,|L1.192|
00007c  f7fffffe          BL       ADC_RegularChannelConfig
;;;112    
;;;113    	/* Enable ADC1 */
;;;114    	ADC_Cmd(ADC1, ENABLE);		  //使能ADC1
000080  2101              MOVS     r1,#1
000082  480f              LDR      r0,|L1.192|
000084  f7fffffe          BL       ADC_Cmd
;;;115    
;;;116    	/* Enable ADC1 reset calibaration register */
;;;117    	ADC_ResetCalibration(ADC1);						//重置ADC1的校准寄存器
000088  480d              LDR      r0,|L1.192|
00008a  f7fffffe          BL       ADC_ResetCalibration
;;;118    	/* Check the end of ADC1 reset calibration register */
;;;119    	while(ADC_GetResetCalibrationStatus(ADC1));		//获取ADC1重置校准寄存器的状态,设置状态则等待
00008e  bf00              NOP      
                  |L1.144|
000090  480b              LDR      r0,|L1.192|
000092  f7fffffe          BL       ADC_GetResetCalibrationStatus
000096  2800              CMP      r0,#0
000098  d1fa              BNE      |L1.144|
;;;120    
;;;121    	/* Start ADC1 calibaration */
;;;122    	ADC_StartCalibration(ADC1);					//开始ADC1的校准状态
00009a  4809              LDR      r0,|L1.192|
00009c  f7fffffe          BL       ADC_StartCalibration
;;;123    	/* Check the end of ADC1 calibration */
;;;124    	while(ADC_GetCalibrationStatus(ADC1));		//等待校准完成
0000a0  bf00              NOP      
                  |L1.162|
0000a2  4807              LDR      r0,|L1.192|
0000a4  f7fffffe          BL       ADC_GetCalibrationStatus
0000a8  2800              CMP      r0,#0
0000aa  d1fa              BNE      |L1.162|
;;;125    
;;;126    	/* Start ADC1 Software Conversion */
;;;127    	ADC_SoftwareStartConvCmd(ADC1, ENABLE);		//使能ADC1的软件转换启动功能
0000ac  2101              MOVS     r1,#1
0000ae  4804              LDR      r0,|L1.192|
0000b0  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;128    }
0000b4  b007              ADD      sp,sp,#0x1c
0000b6  bd00              POP      {pc}
;;;129    
                          ENDP

                  |L1.184|
                          DCD      0x40010c00
                  |L1.188|
                          DCD      0x40010800
                  |L1.192|
                          DCD      0x40012400

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;190    
;;;191    void Delay(__IO u32 nCount)
000000  e000              B        |L2.4|
                  |L2.2|
;;;192    {
;;;193      for(; nCount != 0; nCount--);
000002  1e40              SUBS     r0,r0,#1
                  |L2.4|
000004  2800              CMP      r0,#0
000006  d1fc              BNE      |L2.2|
;;;194    }
000008  4770              BX       lr
;;;195    int main(void)
                          ENDP


                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;159    *******************************************************************************/
;;;160    void NVIC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;161    {
;;;162      
;;;163    
;;;164      NVIC_InitTypeDef NVIC_InitStructure; 
;;;165        
;;;166        NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  													
000002  f44f60e0          MOV      r0,#0x700
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;167        NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;	  
00000a  201c              MOVS     r0,#0x1c
00000c  f88d0000          STRB     r0,[sp,#0]
;;;168        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000010  2000              MOVS     r0,#0
000012  f88d0001          STRB     r0,[sp,#1]
;;;169        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;	
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;170        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2001              MOVS     r0,#1
00001e  f88d0003          STRB     r0,[sp,#3]
;;;171        NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;172    }
000028  bd08              POP      {r3,pc}
;;;173    
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;30     **************************************************/
;;;31     void RCC_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;32     {
;;;33       ErrorStatus HSEStartUpStatus;                    //定义外部高速晶体启动状态枚举变量
;;;34       GPIO_InitTypeDef GPIO_InitStructure;
;;;35     
;;;36       RCC_DeInit();                                    //复位RCC外部设备寄存器到默认值
000002  f7fffffe          BL       RCC_DeInit
;;;37       RCC_HSEConfig(RCC_HSE_ON);                       //打开外部高速晶振
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;38       HSEStartUpStatus = RCC_WaitForHSEStartUp();      //等待外部高速时钟准备好
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4604              MOV      r4,r0
;;;39       if(HSEStartUpStatus == SUCCESS)                  //外部高速时钟已经准别好
000014  2c01              CMP      r4,#1
000016  d124              BNE      |L4.98|
;;;40       {
;;;41         FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); //开启FLASH预读缓冲功能，加速FLASH的读取。所有程序中必须的用法.位置：RCC初始化子函数里面，时钟起振之后
000018  2010              MOVS     r0,#0x10
00001a  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;42         FLASH_SetLatency(FLASH_Latency_2);                    //flash操作的延时
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       FLASH_SetLatency
;;;43           	
;;;44         RCC_HCLKConfig(RCC_SYSCLK_Div1);               //配置AHB(HCLK)时钟等于==SYSCLK
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       RCC_HCLKConfig
;;;45         RCC_PCLK2Config(RCC_HCLK_Div1);                //配置APB2(PCLK2)钟==AHB时钟
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       RCC_PCLK2Config
;;;46         RCC_PCLK1Config(RCC_HCLK_Div2);                //配置APB1(PCLK1)钟==AHB1/2时钟
000030  02a0              LSLS     r0,r4,#10
000032  f7fffffe          BL       RCC_PCLK1Config
;;;47              
;;;48         RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);  //配置PLL时钟 == 外部高速晶体时钟 * 9 = 72MHz
000036  f44f11e0          MOV      r1,#0x1c0000
00003a  0420              LSLS     r0,r4,#16
00003c  f7fffffe          BL       RCC_PLLConfig
;;;49         RCC_PLLCmd(ENABLE);                                   //使能PLL时钟
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       RCC_PLLCmd
;;;50        
;;;51         while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)    //等待PLL时钟就绪
000046  bf00              NOP      
                  |L4.72|
000048  2039              MOVS     r0,#0x39
00004a  f7fffffe          BL       RCC_GetFlagStatus
00004e  2800              CMP      r0,#0
000050  d0fa              BEQ      |L4.72|
;;;52         {
;;;53         }
;;;54         RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);            //配置系统时钟 = PLL时钟
000052  2002              MOVS     r0,#2
000054  f7fffffe          BL       RCC_SYSCLKConfig
;;;55         while(RCC_GetSYSCLKSource() != 0x08)                  //检查PLL时钟是否作为系统时钟
000058  bf00              NOP      
                  |L4.90|
00005a  f7fffffe          BL       RCC_GetSYSCLKSource
00005e  2808              CMP      r0,#8
000060  d1fb              BNE      |L4.90|
                  |L4.98|
;;;56         {
;;;57         }
;;;58       }
;;;59       
;;;60       RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);    //允许AFIO时钟
000062  2101              MOVS     r1,#1
000064  4608              MOV      r0,r1
000066  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;61     
;;;62       /* Enable USB_DISCONNECT GPIO clock */
;;;63       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2008              MOVS     r0,#8
00006e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;64     
;;;65       /* Configure USB pull-up pin */
;;;66       GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
000072  f44f4080          MOV      r0,#0x4000
000076  f8ad0000          STRH     r0,[sp,#0]
;;;67       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00007a  2003              MOVS     r0,#3
00007c  f88d0002          STRB     r0,[sp,#2]
;;;68       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000080  2014              MOVS     r0,#0x14
000082  f88d0003          STRB     r0,[sp,#3]
;;;69       GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
000086  4669              MOV      r1,sp
000088  4801              LDR      r0,|L4.144|
00008a  f7fffffe          BL       GPIO_Init
;;;70     }
00008e  bd38              POP      {r3-r5,pc}
;;;71     
                          ENDP

                  |L4.144|
                          DCD      0x40010c00

                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM2_IRQHandler PROC
;;;180    **************************************************/
;;;181    void TIM2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;182    {
;;;183       if(TIM_GetITStatus(TIM2,TIM_IT_Update)!=RESET)
000002  2101              MOVS     r1,#1
000004  0788              LSLS     r0,r1,#30
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b140              CBZ      r0,|L5.30|
;;;184       {      
;;;185          TIM_ClearITPendingBit(TIM2,TIM_IT_Update);	 //清除中断标志
00000c  2101              MOVS     r1,#1
00000e  0788              LSLS     r0,r1,#30
000010  f7fffffe          BL       TIM_ClearITPendingBit
;;;186          time++;
000014  4802              LDR      r0,|L5.32|
000016  8800              LDRH     r0,[r0,#0]  ; time
000018  1c40              ADDS     r0,r0,#1
00001a  4901              LDR      r1,|L5.32|
00001c  8008              STRH     r0,[r1,#0]
                  |L5.30|
;;;187       }
;;;188    }
00001e  bd10              POP      {r4,pc}
;;;189    
                          ENDP

                  |L5.32|
                          DCD      time

                          AREA ||i.Timer2_Configuration||, CODE, READONLY, ALIGN=1

                  Timer2_Configuration PROC
;;;136    **************************************************/
;;;137    void Timer2_Configuration(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;138    {
;;;139      TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;140        RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2 , ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;141        TIM_DeInit(TIM2);
00000a  f04f4080          MOV      r0,#0x40000000
00000e  f7fffffe          BL       TIM_DeInit
;;;142        TIM_TimeBaseStructure.TIM_Period=1000;	//自动重装载寄存器周期的值(计数值) 
000012  f44f707a          MOV      r0,#0x3e8
000016  f8ad0004          STRH     r0,[sp,#4]
;;;143        /* 累计 TIM_Period个频率后产生一个更新或者中断 */
;;;144        TIM_TimeBaseStructure.TIM_Prescaler= (72 - 1);	//时钟预分频数 72M/72      
00001a  2047              MOVS     r0,#0x47
00001c  f8ad0000          STRH     r0,[sp,#0]
;;;145        TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up; //向上计数模式 
000020  2000              MOVS     r0,#0
000022  f8ad0002          STRH     r0,[sp,#2]
;;;146        TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
000026  4669              MOV      r1,sp
000028  f04f4080          MOV      r0,#0x40000000
00002c  f7fffffe          BL       TIM_TimeBaseInit
;;;147        TIM_ClearFlag(TIM2, TIM_FLAG_Update);	// 清除溢出中断标志 
000030  2101              MOVS     r1,#1
000032  0788              LSLS     r0,r1,#30
000034  f7fffffe          BL       TIM_ClearFlag
;;;148        TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);
000038  2201              MOVS     r2,#1
00003a  4611              MOV      r1,r2
00003c  0790              LSLS     r0,r2,#30
00003e  f7fffffe          BL       TIM_ITConfig
;;;149        TIM_Cmd(TIM2, ENABLE);	// 开启时钟    
000042  2101              MOVS     r1,#1
000044  0788              LSLS     r0,r1,#30
000046  f7fffffe          BL       TIM_Cmd
;;;150        //RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2 , ENABLE);	//先关闭等待使用                          //开启时钟 
;;;151    }
00004a  bd0e              POP      {r1-r3,pc}
;;;152    
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;194    }
;;;195    int main(void)
000000  b508              PUSH     {r3,lr}
;;;196    {
;;;197      	GPIO_InitTypeDef GPIO_InitStructure;
;;;198    
;;;199      RCC_Configuration();
000002  f7fffffe          BL       RCC_Configuration
;;;200      ADC_Configuration();
000006  f7fffffe          BL       ADC_Configuration
;;;201      NVIC_Configuration();
00000a  f7fffffe          BL       NVIC_Configuration
;;;202      Timer2_Configuration();
00000e  f7fffffe          BL       Timer2_Configuration
;;;203      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14;	
000012  f44f40e0          MOV      r0,#0x7000
000016  f8ad0000          STRH     r0,[sp,#0]
;;;204      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;       
00001a  2010              MOVS     r0,#0x10
00001c  f88d0003          STRB     r0,[sp,#3]
;;;205      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000020  2003              MOVS     r0,#3
000022  f88d0002          STRB     r0,[sp,#2]
;;;206      GPIO_Init(GPIOB, &GPIO_InitStructure);  //初始化PB端口
000026  4669              MOV      r1,sp
000028  4846              LDR      r0,|L7.324|
00002a  f7fffffe          BL       GPIO_Init
;;;207      Set_USBClock();
00002e  f7fffffe          BL       Set_USBClock
;;;208      USB_Interrupts_Config();
000032  f7fffffe          BL       USB_Interrupts_Config
;;;209      USB_Init();  
000036  f7fffffe          BL       USB_Init
;;;210      GPIO_SetBits(GPIOB, GPIO_Pin_12 |GPIO_Pin_13 | GPIO_Pin_14);	 // 关闭所有LED
00003a  f44f41e0          MOV      r1,#0x7000
00003e  4841              LDR      r0,|L7.324|
000040  f7fffffe          BL       GPIO_SetBits
;;;211    
;;;212      while (1)
000044  e07d              B        |L7.322|
                  |L7.70|
;;;213      {
;;;214        u8 s1,s2,s3,s4=0;
000046  2700              MOVS     r7,#0
;;;215             if(time==500)
000048  483f              LDR      r0,|L7.328|
00004a  8800              LDRH     r0,[r0,#0]  ; time
00004c  f5b07ffa          CMP      r0,#0x1f4
000050  d176              BNE      |L7.320|
;;;216    		 { 
;;;217    		  time=0; 		 
000052  2000              MOVS     r0,#0
000054  493c              LDR      r1,|L7.328|
000056  8008              STRH     r0,[r1,#0]
;;;218    	      ADC_SoftwareStartConvCmd(ADC1, ENABLE);	        //软件启动ADC转换
000058  2101              MOVS     r1,#1
00005a  483c              LDR      r0,|L7.332|
00005c  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;219    	      while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC ));   //等待转换结束
000060  bf00              NOP      
                  |L7.98|
000062  2102              MOVS     r1,#2
000064  4839              LDR      r0,|L7.332|
000066  f7fffffe          BL       ADC_GetFlagStatus
00006a  2800              CMP      r0,#0
00006c  d0f9              BEQ      |L7.98|
;;;220    	      ad=ADC_GetConversionValue(ADC1);
00006e  4837              LDR      r0,|L7.332|
000070  f7fffffe          BL       ADC_GetConversionValue
000074  4936              LDR      r1,|L7.336|
000076  8008              STRH     r0,[r1,#0]
;;;221    		  adzhi = 3300000/4096*ad/1000;		        //读取ADC值  
000078  4608              MOV      r0,r1
00007a  8800              LDRH     r0,[r0,#0]  ; ad
00007c  f2403125          MOV      r1,#0x325
000080  4348              MULS     r0,r1,r0
000082  f44f717a          MOV      r1,#0x3e8
000086  fb90f0f1          SDIV     r0,r0,r1
00008a  4932              LDR      r1,|L7.340|
00008c  6008              STR      r0,[r1,#0]  ; adzhi
;;;222    		  s1=(adzhi/1000);
00008e  4608              MOV      r0,r1
000090  6800              LDR      r0,[r0,#0]  ; adzhi
000092  f44f717a          MOV      r1,#0x3e8
000096  fbb0f4f1          UDIV     r4,r0,r1
;;;223              s2=(adzhi/100%10);
00009a  482e              LDR      r0,|L7.340|
00009c  6800              LDR      r0,[r0,#0]  ; adzhi
00009e  2164              MOVS     r1,#0x64
0000a0  fbb0f0f1          UDIV     r0,r0,r1
0000a4  210a              MOVS     r1,#0xa
0000a6  fbb0f2f1          UDIV     r2,r0,r1
0000aa  fb010512          MLS      r5,r1,r2,r0
;;;224              s3=(adzhi%100/10);
0000ae  4829              LDR      r0,|L7.340|
0000b0  6800              LDR      r0,[r0,#0]  ; adzhi
0000b2  2164              MOVS     r1,#0x64
0000b4  fbb0f2f1          UDIV     r2,r0,r1
0000b8  fb010012          MLS      r0,r1,r2,r0
0000bc  210a              MOVS     r1,#0xa
0000be  fbb0f6f1          UDIV     r6,r0,r1
;;;225              s4=(adzhi%10);
0000c2  4824              LDR      r0,|L7.340|
0000c4  6800              LDR      r0,[r0,#0]  ; adzhi
0000c6  fbb0f2f1          UDIV     r2,r0,r1
0000ca  fb010712          MLS      r7,r1,r2,r0
;;;226    		  s1=s1+0x30;
0000ce  f1040030          ADD      r0,r4,#0x30
0000d2  b2c4              UXTB     r4,r0
;;;227    		  s2=s2+0x30;
0000d4  f1050030          ADD      r0,r5,#0x30
0000d8  b2c5              UXTB     r5,r0
;;;228    		  s3=s3+0x30;
0000da  f1060030          ADD      r0,r6,#0x30
0000de  b2c6              UXTB     r6,r0
;;;229    		  s4=s4+0x30; 		                    
0000e0  f1070030          ADD      r0,r7,#0x30
0000e4  b2c7              UXTB     r7,r0
;;;230              USART_To_USB_Send_Data('V');
0000e6  2056              MOVS     r0,#0x56
0000e8  f7fffffe          BL       USART_To_USB_Send_Data
;;;231    		  USART_To_USB_Send_Data('o');
0000ec  206f              MOVS     r0,#0x6f
0000ee  f7fffffe          BL       USART_To_USB_Send_Data
;;;232    		  USART_To_USB_Send_Data('l');
0000f2  206c              MOVS     r0,#0x6c
0000f4  f7fffffe          BL       USART_To_USB_Send_Data
;;;233    		  USART_To_USB_Send_Data('t');
0000f8  2074              MOVS     r0,#0x74
0000fa  f7fffffe          BL       USART_To_USB_Send_Data
;;;234    		  USART_To_USB_Send_Data('a');
0000fe  2061              MOVS     r0,#0x61
000100  f7fffffe          BL       USART_To_USB_Send_Data
;;;235    		  USART_To_USB_Send_Data('g');
000104  2067              MOVS     r0,#0x67
000106  f7fffffe          BL       USART_To_USB_Send_Data
;;;236    		  USART_To_USB_Send_Data('e');
00010a  2065              MOVS     r0,#0x65
00010c  f7fffffe          BL       USART_To_USB_Send_Data
;;;237    		  USART_To_USB_Send_Data(':');
000110  203a              MOVS     r0,#0x3a
000112  f7fffffe          BL       USART_To_USB_Send_Data
;;;238    		  USART_To_USB_Send_Data(s1);
000116  4620              MOV      r0,r4
000118  f7fffffe          BL       USART_To_USB_Send_Data
;;;239    		  USART_To_USB_Send_Data(s2);
00011c  4628              MOV      r0,r5
00011e  f7fffffe          BL       USART_To_USB_Send_Data
;;;240    		  USART_To_USB_Send_Data(s3);
000122  4630              MOV      r0,r6
000124  f7fffffe          BL       USART_To_USB_Send_Data
;;;241    		  USART_To_USB_Send_Data(s4);
000128  4638              MOV      r0,r7
00012a  f7fffffe          BL       USART_To_USB_Send_Data
;;;242    		  USART_To_USB_Send_Data('m');
00012e  206d              MOVS     r0,#0x6d
000130  f7fffffe          BL       USART_To_USB_Send_Data
;;;243    		  USART_To_USB_Send_Data('V');
000134  2056              MOVS     r0,#0x56
000136  f7fffffe          BL       USART_To_USB_Send_Data
;;;244    		  USART_To_USB_Send_Data('\n');		  
00013a  200a              MOVS     r0,#0xa
00013c  f7fffffe          BL       USART_To_USB_Send_Data
                  |L7.320|
;;;245    		  
;;;246    		  
;;;247              } 
;;;248    
;;;249    	  	 
;;;250    	                    
;;;251            
;;;252          
;;;253           		  
;;;254      }
000140  bf00              NOP      
                  |L7.322|
000142  e780              B        |L7.70|
;;;255    }
;;;256    
                          ENDP

                  |L7.324|
                          DCD      0x40010c00
                  |L7.328|
                          DCD      time
                  |L7.332|
                          DCD      0x40012400
                  |L7.336|
                          DCD      ||ad||
                  |L7.340|
                          DCD      adzhi

                          AREA ||.data||, DATA, ALIGN=2

                  comm
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  adzhi
                          DCD      0x00000000
                  time
000008  0000              DCW      0x0000
                  ||ah||
00000a  00                DCB      0x00
                  ||al||
00000b  00                DCB      0x00
                  ||ad||
00000c  0000              DCB      0x00,0x00

                  __ARM_use_no_argv EQU 0
