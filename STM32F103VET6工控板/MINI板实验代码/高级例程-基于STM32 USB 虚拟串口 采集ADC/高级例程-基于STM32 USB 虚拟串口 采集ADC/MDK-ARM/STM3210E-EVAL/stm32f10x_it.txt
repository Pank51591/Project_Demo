; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\STM3210E-EVAL\stm32f10x_it.o --depend=.\STM3210E-EVAL\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\inc -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Utilities\STM32_EVAL -I..\Utilities\STM32_EVAL\Common -I..\Utilities\STM32_EVAL\STM3210E_EVAL -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL ..\src\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
;;;81     *******************************************************************************/
;;;82     void BusFault_Handler(void)
000000  bf00              NOP      
                  |L1.2|
;;;83     {
;;;84       /* Go to infinite loop when Bus Fault exception occurs */
;;;85       while (1)
000002  e7fe              B        |L1.2|
;;;86       {
;;;87       }
;;;88     }
;;;89     
                          ENDP


                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;122    *******************************************************************************/
;;;123    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;124    {
;;;125    }
;;;126    
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
;;;51     *******************************************************************************/
;;;52     void HardFault_Handler(void)
000000  bf00              NOP      
                  |L3.2|
;;;53     {
;;;54       /* Go to infinite loop when Hard Fault exception occurs */
;;;55       while (1)
000002  e7fe              B        |L3.2|
;;;56       {
;;;57       }
;;;58     }
;;;59     
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
;;;66     *******************************************************************************/
;;;67     void MemManage_Handler(void)
000000  bf00              NOP      
                  |L4.2|
;;;68     {
;;;69       /* Go to infinite loop when Memory Manage exception occurs */
;;;70       while (1)
000002  e7fe              B        |L4.2|
;;;71       {
;;;72       }
;;;73     }
;;;74     
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;40     *******************************************************************************/
;;;41     void NMI_Handler(void)
000000  4770              BX       lr
;;;42     {
;;;43     }
;;;44     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;133    *******************************************************************************/
;;;134    void PendSV_Handler(void)
000000  4770              BX       lr
;;;135    {
;;;136    }
;;;137    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;111    *******************************************************************************/
;;;112    void SVC_Handler(void)
000000  4770              BX       lr
;;;113    {
;;;114    }
;;;115    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;144    *******************************************************************************/
;;;145    void SysTick_Handler(void)
000000  4770              BX       lr
;;;146    {
;;;147    }
;;;148    
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;175    *******************************************************************************/
;;;176    void USART1_IRQHandler(u8 data)
000000  b510              PUSH     {r4,lr}
;;;177    {
000002  4604              MOV      r4,r0
;;;178      if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  4807              LDR      r0,|L9.40|
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b110              CBZ      r0,|L9.22|
;;;179      {
;;;180        /* Send the received data to the PC Host*/
;;;181        USART_To_USB_Send_Data(data);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       USART_To_USB_Send_Data
                  |L9.22|
;;;182      }
;;;183    
;;;184      /* If overrun condition occurs, clear the ORE flag and recover communication */
;;;185      if (USART_GetFlagStatus(USART1, USART_FLAG_ORE) != RESET)
000016  2108              MOVS     r1,#8
000018  4803              LDR      r0,|L9.40|
00001a  f7fffffe          BL       USART_GetFlagStatus
00001e  b110              CBZ      r0,|L9.38|
;;;186      {
;;;187        (void)USART_ReceiveData(USART1);
000020  4801              LDR      r0,|L9.40|
000022  f7fffffe          BL       USART_ReceiveData
                  |L9.38|
;;;188      }
;;;189    }
000026  bd10              POP      {r4,pc}
;;;190    #endif /* USE_STM3210B_EVAL or USE_STM3210E_EVAL */
                          ENDP

                  |L9.40|
                          DCD      0x40013800

                          AREA ||i.USB_LP_CAN1_RX0_IRQHandler||, CODE, READONLY, ALIGN=1

                  USB_LP_CAN1_RX0_IRQHandler PROC
;;;161    *******************************************************************************/
;;;162    void USB_LP_CAN1_RX0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;163    {
;;;164      USB_Istr();
000002  f7fffffe          BL       USB_Istr
;;;165    }
000006  bd10              POP      {r4,pc}
;;;166    #endif /* STM32F10X_CL */
                          ENDP


                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
;;;96     *******************************************************************************/
;;;97     void UsageFault_Handler(void)
000000  bf00              NOP      
                  |L11.2|
;;;98     {
;;;99       /* Go to infinite loop when Usage Fault exception occurs */
;;;100      while (1)
000002  e7fe              B        |L11.2|
;;;101      {
;;;102      }
;;;103    }
;;;104    
                          ENDP

