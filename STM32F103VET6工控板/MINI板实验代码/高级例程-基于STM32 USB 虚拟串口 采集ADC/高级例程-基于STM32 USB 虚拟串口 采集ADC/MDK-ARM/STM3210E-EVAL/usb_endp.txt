; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\STM3210E-EVAL\usb_endp.o --depend=.\STM3210E-EVAL\usb_endp.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\inc -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Utilities\STM32_EVAL -I..\Utilities\STM32_EVAL\Common -I..\Utilities\STM32_EVAL\STM3210E_EVAL -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL ..\src\usb_endp.c]
                          THUMB

                          AREA ||i.EP1_IN_Callback||, CODE, READONLY, ALIGN=2

                  EP1_IN_Callback PROC
;;;49     *******************************************************************************/
;;;50     void EP1_IN_Callback (void)				  //USB发送完回调函数
000000  b570              PUSH     {r4-r6,lr}
;;;51     {
;;;52       uint16_t USB_Tx_ptr;
;;;53       uint16_t USB_Tx_length;
;;;54       
;;;55       if (USB_Tx_State == 1)
000002  481e              LDR      r0,|L1.124|
000004  7800              LDRB     r0,[r0,#0]  ; USB_Tx_State
000006  2801              CMP      r0,#1
000008  d136              BNE      |L1.120|
;;;56       {
;;;57         if (USART_Rx_length == 0) 
00000a  481d              LDR      r0,|L1.128|
00000c  6800              LDR      r0,[r0,#0]  ; USART_Rx_length
00000e  b918              CBNZ     r0,|L1.24|
;;;58         {
;;;59           USB_Tx_State = 0;
000010  2000              MOVS     r0,#0
000012  491a              LDR      r1,|L1.124|
000014  7008              STRB     r0,[r1,#0]
000016  e02f              B        |L1.120|
                  |L1.24|
;;;60         }
;;;61         else 
;;;62         {
;;;63           if (USART_Rx_length > VIRTUAL_COM_PORT_DATA_SIZE){
000018  4819              LDR      r0,|L1.128|
00001a  6800              LDR      r0,[r0,#0]  ; USART_Rx_length
00001c  2840              CMP      r0,#0x40
00001e  d90e              BLS      |L1.62|
;;;64             USB_Tx_ptr = USART_Rx_ptr_out;
000020  4818              LDR      r0,|L1.132|
000022  6800              LDR      r0,[r0,#0]  ; USART_Rx_ptr_out
000024  b285              UXTH     r5,r0
;;;65             USB_Tx_length = VIRTUAL_COM_PORT_DATA_SIZE;
000026  2440              MOVS     r4,#0x40
;;;66             
;;;67             USART_Rx_ptr_out += VIRTUAL_COM_PORT_DATA_SIZE;
000028  4816              LDR      r0,|L1.132|
00002a  6800              LDR      r0,[r0,#0]  ; USART_Rx_ptr_out
00002c  3040              ADDS     r0,r0,#0x40
00002e  4915              LDR      r1,|L1.132|
000030  6008              STR      r0,[r1,#0]  ; USART_Rx_ptr_out
;;;68             USART_Rx_length -= VIRTUAL_COM_PORT_DATA_SIZE;    
000032  4813              LDR      r0,|L1.128|
000034  6800              LDR      r0,[r0,#0]  ; USART_Rx_length
000036  3840              SUBS     r0,r0,#0x40
000038  4911              LDR      r1,|L1.128|
00003a  6008              STR      r0,[r1,#0]  ; USART_Rx_length
00003c  e00f              B        |L1.94|
                  |L1.62|
;;;69           }
;;;70           else 
;;;71           {
;;;72             USB_Tx_ptr = USART_Rx_ptr_out;
00003e  4811              LDR      r0,|L1.132|
000040  6800              LDR      r0,[r0,#0]  ; USART_Rx_ptr_out
000042  b285              UXTH     r5,r0
;;;73             USB_Tx_length = USART_Rx_length;
000044  480e              LDR      r0,|L1.128|
000046  6800              LDR      r0,[r0,#0]  ; USART_Rx_length
000048  b284              UXTH     r4,r0
;;;74             
;;;75             USART_Rx_ptr_out += USART_Rx_length;
00004a  480e              LDR      r0,|L1.132|
00004c  6800              LDR      r0,[r0,#0]  ; USART_Rx_ptr_out
00004e  490c              LDR      r1,|L1.128|
000050  6809              LDR      r1,[r1,#0]  ; USART_Rx_length
000052  4408              ADD      r0,r0,r1
000054  490b              LDR      r1,|L1.132|
000056  6008              STR      r0,[r1,#0]  ; USART_Rx_ptr_out
;;;76             USART_Rx_length = 0;
000058  2000              MOVS     r0,#0
00005a  4909              LDR      r1,|L1.128|
00005c  6008              STR      r0,[r1,#0]  ; USART_Rx_length
                  |L1.94|
;;;77           }
;;;78           
;;;79     #ifdef USE_STM3210C_EVAL
;;;80           USB_SIL_Write(EP1_IN, &USART_Rx_Buffer[USB_Tx_ptr], USB_Tx_length);  
;;;81     #else
;;;82           UserToPMABufferCopy(&USART_Rx_Buffer[USB_Tx_ptr], ENDP1_TXADDR, USB_Tx_length);
00005e  490a              LDR      r1,|L1.136|
000060  1948              ADDS     r0,r1,r5
000062  4622              MOV      r2,r4
000064  21c0              MOVS     r1,#0xc0
000066  f7fffffe          BL       UserToPMABufferCopy
;;;83           SetEPTxCount(ENDP1, USB_Tx_length);
00006a  4621              MOV      r1,r4
00006c  2001              MOVS     r0,#1
00006e  f7fffffe          BL       SetEPTxCount
;;;84           SetEPTxValid(ENDP1); 
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       SetEPTxValid
                  |L1.120|
;;;85     #endif  
;;;86         }
;;;87       }
;;;88     }
000078  bd70              POP      {r4-r6,pc}
;;;89     
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
                          DCD      USB_Tx_State
                  |L1.128|
                          DCD      USART_Rx_length
                  |L1.132|
                          DCD      USART_Rx_ptr_out
                  |L1.136|
                          DCD      USART_Rx_Buffer

                          AREA ||i.EP3_OUT_Callback||, CODE, READONLY, ALIGN=2

                  EP3_OUT_Callback PROC
;;;96     *******************************************************************************/
;;;97     void EP3_OUT_Callback(void)		 //EP3 OUT的回调函数，当EP3接收到数据时候中断调用该函数
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99       uint16_t USB_Rx_Cnt;
;;;100      
;;;101      /* Get the received data buffer and update the counter */
;;;102      USB_Rx_Cnt = USB_SIL_Read(EP3_OUT, USB_Rx_Buffer);
000002  4906              LDR      r1,|L2.28|
000004  2003              MOVS     r0,#3
000006  f7fffffe          BL       USB_SIL_Read
00000a  b284              UXTH     r4,r0
;;;103      
;;;104      /* USB data will be immediately processed, this allow next USB traffic beeing 
;;;105      NAKed till the end of the USART Xfet */
;;;106      
;;;107      //USB_To_USART_Send_Data(USB_Rx_Buffer, USB_Rx_Cnt);
;;;108      comm = USB_Rx_Buffer[0];
00000c  4803              LDR      r0,|L2.28|
00000e  7800              LDRB     r0,[r0,#0]  ; USB_Rx_Buffer
000010  4903              LDR      r1,|L2.32|
000012  7008              STRB     r0,[r1,#0]
;;;109      
;;;110    #ifndef STM32F10X_CL
;;;111      /* Enable the receive of data on EP3 */
;;;112      SetEPRxValid(ENDP3);
000014  2003              MOVS     r0,#3
000016  f7fffffe          BL       SetEPRxValid
;;;113    #endif /* STM32F10X_CL */
;;;114    }
00001a  bd10              POP      {r4,pc}
;;;115    
                          ENDP

                  |L2.28|
                          DCD      USB_Rx_Buffer
                  |L2.32|
                          DCD      comm

                          AREA ||i.SOF_Callback||, CODE, READONLY, ALIGN=2

                  SOF_Callback PROC
;;;126    #else
;;;127    void SOF_Callback(void)
000000  b510              PUSH     {r4,lr}
;;;128    #endif /* STM32F10X_CL */
;;;129    {
;;;130      static uint32_t FrameCount = 0;
;;;131      
;;;132      if(bDeviceState == CONFIGURED)
000002  4809              LDR      r0,|L3.40|
000004  6800              LDR      r0,[r0,#0]  ; bDeviceState
000006  2805              CMP      r0,#5
000008  d10c              BNE      |L3.36|
;;;133      {
;;;134        if (FrameCount++ == VCOMPORT_IN_FRAME_INTERVAL)
00000a  4808              LDR      r0,|L3.44|
00000c  6801              LDR      r1,[r0,#0]  ; FrameCount
00000e  6800              LDR      r0,[r0,#0]  ; FrameCount
000010  1c40              ADDS     r0,r0,#1
000012  4a06              LDR      r2,|L3.44|
000014  6010              STR      r0,[r2,#0]  ; FrameCount
000016  2905              CMP      r1,#5
000018  d104              BNE      |L3.36|
;;;135        {
;;;136          /* Reset the frame counter */
;;;137          FrameCount = 0;
00001a  2000              MOVS     r0,#0
00001c  4611              MOV      r1,r2
00001e  6008              STR      r0,[r1,#0]  ; FrameCount
;;;138          
;;;139          /* Check the data to be sent through IN pipe */
;;;140          Handle_USBAsynchXfer();
000020  f7fffffe          BL       Handle_USBAsynchXfer
                  |L3.36|
;;;141        }
;;;142      }  
;;;143    }
000024  bd10              POP      {r4,pc}
;;;144    /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      bDeviceState
                  |L3.44|
                          DCD      FrameCount

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USB_Rx_Buffer
                          %        64

                          AREA ||.data||, DATA, ALIGN=2

                  FrameCount
                          DCD      0x00000000
