; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\STM3210E-EVAL\main.o --depend=.\STM3210E-EVAL\main.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\inc -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Utilities\STM32_EVAL -I..\Utilities\STM32_EVAL\Common -I..\Utilities\STM32_EVAL\STM3210E_EVAL -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL ..\src\main.c]
                          THUMB

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;31     **************************************************/
;;;32     void RCC_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;33     {
;;;34       ErrorStatus HSEStartUpStatus;                    //定义外部高速晶体启动状态枚举变量
;;;35       GPIO_InitTypeDef GPIO_InitStructure;
;;;36     
;;;37       RCC_DeInit();                                    //复位RCC外部设备寄存器到默认值
000002  f7fffffe          BL       RCC_DeInit
;;;38       RCC_HSEConfig(RCC_HSE_ON);                       //打开外部高速晶振
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;39       HSEStartUpStatus = RCC_WaitForHSEStartUp();      //等待外部高速时钟准备好
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4604              MOV      r4,r0
;;;40       if(HSEStartUpStatus == SUCCESS)                  //外部高速时钟已经准别好
000014  2c01              CMP      r4,#1
000016  d124              BNE      |L1.98|
;;;41       {
;;;42         FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); //开启FLASH预读缓冲功能，加速FLASH的读取。所有程序中必须的用法.位置：RCC初始化子函数里面，时钟起振之后
000018  2010              MOVS     r0,#0x10
00001a  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;43         FLASH_SetLatency(FLASH_Latency_2);                    //flash操作的延时
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       FLASH_SetLatency
;;;44           	
;;;45         RCC_HCLKConfig(RCC_SYSCLK_Div1);               //配置AHB(HCLK)时钟等于==SYSCLK
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       RCC_HCLKConfig
;;;46         RCC_PCLK2Config(RCC_HCLK_Div1);                //配置APB2(PCLK2)钟==AHB时钟
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       RCC_PCLK2Config
;;;47         RCC_PCLK1Config(RCC_HCLK_Div2);                //配置APB1(PCLK1)钟==AHB1/2时钟
000030  02a0              LSLS     r0,r4,#10
000032  f7fffffe          BL       RCC_PCLK1Config
;;;48              
;;;49         RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);  //配置PLL时钟 == 外部高速晶体时钟 * 9 = 72MHz
000036  f44f11e0          MOV      r1,#0x1c0000
00003a  0420              LSLS     r0,r4,#16
00003c  f7fffffe          BL       RCC_PLLConfig
;;;50         RCC_PLLCmd(ENABLE);                                   //使能PLL时钟
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       RCC_PLLCmd
;;;51        
;;;52         while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)    //等待PLL时钟就绪
000046  bf00              NOP      
                  |L1.72|
000048  2039              MOVS     r0,#0x39
00004a  f7fffffe          BL       RCC_GetFlagStatus
00004e  2800              CMP      r0,#0
000050  d0fa              BEQ      |L1.72|
;;;53         {
;;;54         }
;;;55         RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);            //配置系统时钟 = PLL时钟
000052  2002              MOVS     r0,#2
000054  f7fffffe          BL       RCC_SYSCLKConfig
;;;56         while(RCC_GetSYSCLKSource() != 0x08)                  //检查PLL时钟是否作为系统时钟
000058  bf00              NOP      
                  |L1.90|
00005a  f7fffffe          BL       RCC_GetSYSCLKSource
00005e  2808              CMP      r0,#8
000060  d1fb              BNE      |L1.90|
                  |L1.98|
;;;57         {
;;;58         }
;;;59       }
;;;60       
;;;61       RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);    //允许AFIO时钟
000062  2101              MOVS     r1,#1
000064  4608              MOV      r0,r1
000066  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;62     
;;;63       /* Enable USB_DISCONNECT GPIO clock */
;;;64       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2008              MOVS     r0,#8
00006e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;65     
;;;66       /* Configure USB pull-up pin */
;;;67       GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
000072  f44f4080          MOV      r0,#0x4000
000076  f8ad0000          STRH     r0,[sp,#0]
;;;68       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00007a  2003              MOVS     r0,#3
00007c  f88d0002          STRB     r0,[sp,#2]
;;;69       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000080  2014              MOVS     r0,#0x14
000082  f88d0003          STRB     r0,[sp,#3]
;;;70       GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
000086  4669              MOV      r1,sp
000088  480a              LDR      r0,|L1.180|
00008a  f7fffffe          BL       GPIO_Init
;;;71     
;;;72        /* Enable GPIOA, GPIOD and USART1 clock */
;;;73       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOD, ENABLE);
00008e  2101              MOVS     r1,#1
000090  202c              MOVS     r0,#0x2c
000092  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;74     
;;;75       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 ;
000096  f44f40e0          MOV      r0,#0x7000
00009a  f8ad0000          STRH     r0,[sp,#0]
;;;76       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00009e  2010              MOVS     r0,#0x10
0000a0  f88d0003          STRB     r0,[sp,#3]
;;;77       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a4  2003              MOVS     r0,#3
0000a6  f88d0002          STRB     r0,[sp,#2]
;;;78       	GPIO_Init(GPIOB, &GPIO_InitStructure); 
0000aa  4669              MOV      r1,sp
0000ac  4801              LDR      r0,|L1.180|
0000ae  f7fffffe          BL       GPIO_Init
;;;79     	
;;;80     }
0000b2  bd38              POP      {r3-r5,pc}
;;;81     
                          ENDP

                  |L1.180|
                          DCD      0x40010c00

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;85     
;;;86     int main(void)
000000  f7fffffe          BL       RCC_Configuration
;;;87     {
;;;88       	
;;;89     
;;;90       RCC_Configuration();
;;;91       Set_USBClock();
000004  f7fffffe          BL       Set_USBClock
;;;92       USB_Interrupts_Config();
000008  f7fffffe          BL       USB_Interrupts_Config
;;;93       USB_Init();
00000c  f7fffffe          BL       USB_Init
;;;94       GPIO_SetBits(GPIOB, GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 ); //关闭3个LED
000010  f44f41e0          MOV      r1,#0x7000
000014  4820              LDR      r0,|L2.152|
000016  f7fffffe          BL       GPIO_SetBits
;;;95        
;;;96     
;;;97       while (1)
00001a  e03c              B        |L2.150|
                  |L2.28|
;;;98       {
;;;99     
;;;100       
;;;101    	if (count_out != 0)	//判断有无数据接收到
00001c  481f              LDR      r0,|L2.156|
00001e  8800              LDRH     r0,[r0,#0]  ; count_out
000020  b3c8              CBZ      r0,|L2.150|
;;;102        {  
;;;103    	  
;;;104          
;;;105    	  if(USB_Rx_Buffer[0]==0x01){GPIO_ResetBits(GPIOB, GPIO_Pin_14 );
000022  481f              LDR      r0,|L2.160|
000024  7800              LDRB     r0,[r0,#0]  ; USB_Rx_Buffer
000026  2801              CMP      r0,#1
000028  d109              BNE      |L2.62|
00002a  0381              LSLS     r1,r0,#14
00002c  481a              LDR      r0,|L2.152|
00002e  f7fffffe          BL       GPIO_ResetBits
;;;106    	                          USB_Send_string("LED1 点亮  \r\n");
000032  a01c              ADR      r0,|L2.164|
000034  f7fffffe          BL       USB_Send_string
;;;107    							  
;;;108    							  count_out=0;
000038  2000              MOVS     r0,#0
00003a  4918              LDR      r1,|L2.156|
00003c  8008              STRH     r0,[r1,#0]
                  |L2.62|
;;;109    							 }	//如果接收到的输出是0X01，点亮led1
;;;110    	  if(USB_Rx_Buffer[0]==0x02){GPIO_ResetBits(GPIOB, GPIO_Pin_12 );
00003e  4818              LDR      r0,|L2.160|
000040  7800              LDRB     r0,[r0,#0]  ; USB_Rx_Buffer
000042  2802              CMP      r0,#2
000044  d109              BNE      |L2.90|
000046  02c1              LSLS     r1,r0,#11
000048  4813              LDR      r0,|L2.152|
00004a  f7fffffe          BL       GPIO_ResetBits
;;;111    	                          USB_Send_string("LED2 点亮\r\n");
00004e  a019              ADR      r0,|L2.180|
000050  f7fffffe          BL       USB_Send_string
;;;112    							  count_out=0;
000054  2000              MOVS     r0,#0
000056  4911              LDR      r1,|L2.156|
000058  8008              STRH     r0,[r1,#0]
                  |L2.90|
;;;113    							  }	
;;;114    							  //如果接收到的输出是0X02，点亮led2
;;;115    	  if(USB_Rx_Buffer[0]==0x03){GPIO_ResetBits(GPIOB, GPIO_Pin_13 );
00005a  4811              LDR      r0,|L2.160|
00005c  7800              LDRB     r0,[r0,#0]  ; USB_Rx_Buffer
00005e  2803              CMP      r0,#3
000060  d10a              BNE      |L2.120|
000062  f44f5100          MOV      r1,#0x2000
000066  480c              LDR      r0,|L2.152|
000068  f7fffffe          BL       GPIO_ResetBits
;;;116    	                          USB_Send_string("LED3 点亮\r\n");
00006c  a014              ADR      r0,|L2.192|
00006e  f7fffffe          BL       USB_Send_string
;;;117    							  count_out=0;
000072  2000              MOVS     r0,#0
000074  4909              LDR      r1,|L2.156|
000076  8008              STRH     r0,[r1,#0]
                  |L2.120|
;;;118    							  }	
;;;119    							  //如果接收到的输出是0X03，点亮led3
;;;120    	  if(USB_Rx_Buffer[0]==0x04){GPIO_SetBits(GPIOB, GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 );
000078  4809              LDR      r0,|L2.160|
00007a  7800              LDRB     r0,[r0,#0]  ; USB_Rx_Buffer
00007c  2804              CMP      r0,#4
00007e  d10a              BNE      |L2.150|
000080  f44f41e0          MOV      r1,#0x7000
000084  4804              LDR      r0,|L2.152|
000086  f7fffffe          BL       GPIO_SetBits
;;;121    	                          USB_Send_string("LED 全灭\r\n");
00008a  a010              ADR      r0,|L2.204|
00008c  f7fffffe          BL       USB_Send_string
;;;122    							  count_out=0;
000090  2000              MOVS     r0,#0
000092  4902              LDR      r1,|L2.156|
000094  8008              STRH     r0,[r1,#0]
                  |L2.150|
000096  e7c1              B        |L2.28|
;;;123    							  } //如果接收到的输出是0X04，//关闭3个LED  
;;;124        }         
;;;125            
;;;126          
;;;127           		  
;;;128      }
;;;129    }
;;;130    
                          ENDP

                  |L2.152|
                          DCD      0x40010c00
                  |L2.156|
                          DCD      count_out
                  |L2.160|
                          DCD      USB_Rx_Buffer
                  |L2.164|
0000a4  4c454431          DCB      "LED1 ",181,227,193,193,"  \r\n",0
0000a8  20b5e3c1
0000ac  c120200d
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L2.180|
0000b4  4c454432          DCB      "LED2 ",181,227,193,193,"\r\n",0
0000b8  20b5e3c1
0000bc  c10d0a00
                  |L2.192|
0000c0  4c454433          DCB      "LED3 ",181,227,193,193,"\r\n",0
0000c4  20b5e3c1
0000c8  c10d0a00
                  |L2.204|
0000cc  4c454420          DCB      "LED ",200,171,195,240,"\r\n",0
0000d0  c8abc3f0
0000d4  0d0a00  
0000d7  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  adzhi
                          DCD      0x00000000
                  time
000004  0000              DCW      0x0000
                  ||ad||
000006  0000              DCB      0x00,0x00

                  __ARM_use_no_argv EQU 0
