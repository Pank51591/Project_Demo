; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\STM3210E-EVAL\hw_config.o --depend=.\STM3210E-EVAL\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\inc -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Utilities\STM32_EVAL -I..\Utilities\STM32_EVAL\Common -I..\Utilities\STM32_EVAL\STM3210E_EVAL -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL ..\src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;156    *******************************************************************************/
;;;157    void Enter_LowPowerMode(void)
000000  2003              MOVS     r0,#3
;;;158    {
;;;159      /* Set the device state to suspend */
;;;160      bDeviceState = SUSPENDED;
000002  4901              LDR      r1,|L1.8|
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;161    }
000006  4770              BX       lr
;;;162    
                          ENDP

                  |L1.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;486    *******************************************************************************/
;;;487    void Get_SerialNum(void)
000000  b570              PUSH     {r4-r6,lr}
;;;488    {
;;;489      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;490    
;;;491      Device_Serial0 = *(__IO uint32_t*)(0x1FFFF7E8);
000002  480a              LDR      r0,|L2.44|
000004  6804              LDR      r4,[r0,#0]
;;;492      Device_Serial1 = *(__IO uint32_t*)(0x1FFFF7EC);
000006  480a              LDR      r0,|L2.48|
000008  f8d057ec          LDR      r5,[r0,#0x7ec]
;;;493      Device_Serial2 = *(__IO uint32_t*)(0x1FFFF7F0);
00000c  4809              LDR      r0,|L2.52|
00000e  6806              LDR      r6,[r0,#0]
;;;494    
;;;495      Device_Serial0 += Device_Serial2;
000010  4434              ADD      r4,r4,r6
;;;496    
;;;497      if (Device_Serial0 != 0)
000012  b154              CBZ      r4,|L2.42|
;;;498      {
;;;499        IntToUnicode (Device_Serial0, &Virtual_Com_Port_StringSerial[2] , 8);
000014  2208              MOVS     r2,#8
000016  4908              LDR      r1,|L2.56|
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       IntToUnicode
;;;500        IntToUnicode (Device_Serial1, &Virtual_Com_Port_StringSerial[18], 4);
00001e  2204              MOVS     r2,#4
000020  4905              LDR      r1,|L2.56|
000022  3110              ADDS     r1,r1,#0x10
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       IntToUnicode
                  |L2.42|
;;;501      }
;;;502    }
00002a  bd70              POP      {r4-r6,pc}
;;;503    
                          ENDP

                  |L2.44|
                          DCD      0x1ffff7e8
                  |L2.48|
                          DCD      0x1ffff000
                  |L2.52|
                          DCD      0x1ffff7f0
                  |L2.56|
                          DCD      Virtual_Com_Port_StringSerial+0x2

                          AREA ||i.Handle_USBAsynchXfer||, CODE, READONLY, ALIGN=2

                  Handle_USBAsynchXfer PROC
;;;386    *******************************************************************************/
;;;387    void Handle_USBAsynchXfer (void)
000000  b570              PUSH     {r4-r6,lr}
;;;388    {
;;;389      
;;;390      uint16_t USB_Tx_ptr;
;;;391      uint16_t USB_Tx_length;
;;;392      
;;;393      if(USB_Tx_State != 1)
000002  482f              LDR      r0,|L3.192|
000004  7800              LDRB     r0,[r0,#0]  ; USB_Tx_State
000006  2801              CMP      r0,#1
000008  d058              BEQ      |L3.188|
;;;394      {
;;;395        if (USART_Rx_ptr_out == USART_RX_DATA_SIZE)
00000a  482e              LDR      r0,|L3.196|
00000c  6800              LDR      r0,[r0,#0]  ; USART_Rx_ptr_out
00000e  f5b06f00          CMP      r0,#0x800
000012  d102              BNE      |L3.26|
;;;396        {
;;;397          USART_Rx_ptr_out = 0;
000014  2000              MOVS     r0,#0
000016  492b              LDR      r1,|L3.196|
000018  6008              STR      r0,[r1,#0]  ; USART_Rx_ptr_out
                  |L3.26|
;;;398        }
;;;399        
;;;400        if(USART_Rx_ptr_out == USART_Rx_ptr_in) 
00001a  482a              LDR      r0,|L3.196|
00001c  6800              LDR      r0,[r0,#0]  ; USART_Rx_ptr_out
00001e  492a              LDR      r1,|L3.200|
000020  6809              LDR      r1,[r1,#0]  ; USART_Rx_ptr_in
000022  4288              CMP      r0,r1
000024  d103              BNE      |L3.46|
;;;401        {
;;;402          USB_Tx_State = 0; 
000026  2000              MOVS     r0,#0
000028  4925              LDR      r1,|L3.192|
00002a  7008              STRB     r0,[r1,#0]
                  |L3.44|
;;;403          return;
;;;404        }
;;;405        
;;;406        if(USART_Rx_ptr_out > USART_Rx_ptr_in) /* rollback */
;;;407        { 
;;;408          USART_Rx_length = USART_RX_DATA_SIZE - USART_Rx_ptr_out;
;;;409        }
;;;410        else 
;;;411        {
;;;412          USART_Rx_length = USART_Rx_ptr_in - USART_Rx_ptr_out;
;;;413        }
;;;414        
;;;415        if (USART_Rx_length > VIRTUAL_COM_PORT_DATA_SIZE)
;;;416        {
;;;417          USB_Tx_ptr = USART_Rx_ptr_out;
;;;418          USB_Tx_length = VIRTUAL_COM_PORT_DATA_SIZE;
;;;419          
;;;420          USART_Rx_ptr_out += VIRTUAL_COM_PORT_DATA_SIZE;	
;;;421          USART_Rx_length -= VIRTUAL_COM_PORT_DATA_SIZE;	
;;;422        }
;;;423        else
;;;424        {
;;;425          USB_Tx_ptr = USART_Rx_ptr_out;
;;;426          USB_Tx_length = USART_Rx_length;
;;;427          
;;;428          USART_Rx_ptr_out += USART_Rx_length;
;;;429          USART_Rx_length = 0;
;;;430        }
;;;431        USB_Tx_State = 1; 
;;;432        
;;;433    #ifdef USE_STM3210C_EVAL
;;;434        USB_SIL_Write(EP1_IN, &USART_Rx_Buffer[USB_Tx_ptr], USB_Tx_length);  
;;;435    #else
;;;436        UserToPMABufferCopy(&USART_Rx_Buffer[USB_Tx_ptr], ENDP1_TXADDR, USB_Tx_length);
;;;437        SetEPTxCount(ENDP1, USB_Tx_length);
;;;438        SetEPTxValid(ENDP1); 
;;;439    #endif
;;;440      }  
;;;441      
;;;442    }
00002c  bd70              POP      {r4-r6,pc}
                  |L3.46|
00002e  4825              LDR      r0,|L3.196|
000030  6800              LDR      r0,[r0,#0]            ;406  ; USART_Rx_ptr_out
000032  4925              LDR      r1,|L3.200|
000034  6809              LDR      r1,[r1,#0]            ;406  ; USART_Rx_ptr_in
000036  4288              CMP      r0,r1                 ;406
000038  d906              BLS      |L3.72|
00003a  4822              LDR      r0,|L3.196|
00003c  6800              LDR      r0,[r0,#0]            ;408  ; USART_Rx_ptr_out
00003e  f5c06000          RSB      r0,r0,#0x800          ;408
000042  4922              LDR      r1,|L3.204|
000044  6008              STR      r0,[r1,#0]            ;408  ; USART_Rx_length
000046  e006              B        |L3.86|
                  |L3.72|
000048  481f              LDR      r0,|L3.200|
00004a  6800              LDR      r0,[r0,#0]            ;412  ; USART_Rx_ptr_in
00004c  491d              LDR      r1,|L3.196|
00004e  6809              LDR      r1,[r1,#0]            ;412  ; USART_Rx_ptr_out
000050  1a40              SUBS     r0,r0,r1              ;412
000052  491e              LDR      r1,|L3.204|
000054  6008              STR      r0,[r1,#0]            ;412  ; USART_Rx_length
                  |L3.86|
000056  481d              LDR      r0,|L3.204|
000058  6800              LDR      r0,[r0,#0]            ;415  ; USART_Rx_length
00005a  2840              CMP      r0,#0x40              ;415
00005c  d90e              BLS      |L3.124|
00005e  4819              LDR      r0,|L3.196|
000060  6800              LDR      r0,[r0,#0]            ;417  ; USART_Rx_ptr_out
000062  b285              UXTH     r5,r0                 ;417
000064  2440              MOVS     r4,#0x40              ;418
000066  4817              LDR      r0,|L3.196|
000068  6800              LDR      r0,[r0,#0]            ;420  ; USART_Rx_ptr_out
00006a  3040              ADDS     r0,r0,#0x40           ;420
00006c  4915              LDR      r1,|L3.196|
00006e  6008              STR      r0,[r1,#0]            ;420  ; USART_Rx_ptr_out
000070  4816              LDR      r0,|L3.204|
000072  6800              LDR      r0,[r0,#0]            ;421  ; USART_Rx_length
000074  3840              SUBS     r0,r0,#0x40           ;421
000076  4915              LDR      r1,|L3.204|
000078  6008              STR      r0,[r1,#0]            ;421  ; USART_Rx_length
00007a  e00f              B        |L3.156|
                  |L3.124|
00007c  4811              LDR      r0,|L3.196|
00007e  6800              LDR      r0,[r0,#0]            ;425  ; USART_Rx_ptr_out
000080  b285              UXTH     r5,r0                 ;425
000082  4812              LDR      r0,|L3.204|
000084  6800              LDR      r0,[r0,#0]            ;426  ; USART_Rx_length
000086  b284              UXTH     r4,r0                 ;426
000088  480e              LDR      r0,|L3.196|
00008a  6800              LDR      r0,[r0,#0]            ;428  ; USART_Rx_ptr_out
00008c  490f              LDR      r1,|L3.204|
00008e  6809              LDR      r1,[r1,#0]            ;428  ; USART_Rx_length
000090  4408              ADD      r0,r0,r1              ;428
000092  490c              LDR      r1,|L3.196|
000094  6008              STR      r0,[r1,#0]            ;428  ; USART_Rx_ptr_out
000096  2000              MOVS     r0,#0                 ;429
000098  490c              LDR      r1,|L3.204|
00009a  6008              STR      r0,[r1,#0]            ;429  ; USART_Rx_length
                  |L3.156|
00009c  2001              MOVS     r0,#1                 ;431
00009e  4908              LDR      r1,|L3.192|
0000a0  7008              STRB     r0,[r1,#0]            ;431
0000a2  490b              LDR      r1,|L3.208|
0000a4  1948              ADDS     r0,r1,r5              ;436
0000a6  4622              MOV      r2,r4                 ;436
0000a8  21c0              MOVS     r1,#0xc0              ;436
0000aa  f7fffffe          BL       UserToPMABufferCopy
0000ae  4621              MOV      r1,r4                 ;437
0000b0  2001              MOVS     r0,#1                 ;437
0000b2  f7fffffe          BL       SetEPTxCount
0000b6  2001              MOVS     r0,#1                 ;438
0000b8  f7fffffe          BL       SetEPTxValid
                  |L3.188|
0000bc  bf00              NOP      
0000be  e7b5              B        |L3.44|
;;;443    /*******************************************************************************
                          ENDP

                  |L3.192|
                          DCD      USB_Tx_State
                  |L3.196|
                          DCD      USART_Rx_ptr_out
                  |L3.200|
                          DCD      USART_Rx_ptr_in
                  |L3.204|
                          DCD      USART_Rx_length
                  |L3.208|
                          DCD      USART_Rx_Buffer

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=1

                  IntToUnicode PROC
;;;510    *******************************************************************************/
;;;511    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b530              PUSH     {r4,r5,lr}
;;;512    {
000002  460b              MOV      r3,r1
;;;513      uint8_t idx = 0;
000004  2100              MOVS     r1,#0
;;;514      
;;;515      for( idx = 0 ; idx < len ; idx ++)
000006  bf00              NOP      
000008  e016              B        |L4.56|
                  |L4.10|
;;;516      {
;;;517        if( ((value >> 28)) < 0xA )
00000a  240a              MOVS     r4,#0xa
00000c  ebb47f10          CMP      r4,r0,LSR #28
000010  d905              BLS      |L4.30|
;;;518        {
;;;519          pbuf[ 2* idx] = (value >> 28) + '0';
000012  2430              MOVS     r4,#0x30
000014  eb047410          ADD      r4,r4,r0,LSR #28
000018  f8034011          STRB     r4,[r3,r1,LSL #1]
00001c  e005              B        |L4.42|
                  |L4.30|
;;;520        }
;;;521        else
;;;522        {
;;;523          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
00001e  2441              MOVS     r4,#0x41
000020  eb047410          ADD      r4,r4,r0,LSR #28
000024  3c0a              SUBS     r4,r4,#0xa
000026  f8034011          STRB     r4,[r3,r1,LSL #1]
                  |L4.42|
;;;524        }
;;;525        
;;;526        value = value << 4;
00002a  0100              LSLS     r0,r0,#4
;;;527        
;;;528        pbuf[ 2* idx + 1] = 0;
00002c  2500              MOVS     r5,#0
00002e  004c              LSLS     r4,r1,#1
000030  1c64              ADDS     r4,r4,#1
000032  551d              STRB     r5,[r3,r4]
000034  1c4c              ADDS     r4,r1,#1              ;515
000036  b2e1              UXTB     r1,r4                 ;515
                  |L4.56|
000038  4291              CMP      r1,r2                 ;515
00003a  dbe6              BLT      |L4.10|
;;;529      }
;;;530    }
00003c  bd30              POP      {r4,r5,pc}
;;;531    #ifdef STM32F10X_CL
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;168    *******************************************************************************/
;;;169    void Leave_LowPowerMode(void)
000000  4805              LDR      r0,|L5.24|
;;;170    {
;;;171      DEVICE_INFO *pInfo = &Device_Info;
;;;172    
;;;173      /* Set the device state to the correct state */
;;;174      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
000004  b119              CBZ      r1,|L5.14|
;;;175      {
;;;176        /* Device configured */
;;;177        bDeviceState = CONFIGURED;
000006  2105              MOVS     r1,#5
000008  4a04              LDR      r2,|L5.28|
00000a  6011              STR      r1,[r2,#0]  ; bDeviceState
00000c  e002              B        |L5.20|
                  |L5.14|
;;;178      }
;;;179      else
;;;180      {
;;;181        bDeviceState = ATTACHED;
00000e  2101              MOVS     r1,#1
000010  4a02              LDR      r2,|L5.28|
000012  6011              STR      r1,[r2,#0]  ; bDeviceState
                  |L5.20|
;;;182      }
;;;183    }
000014  4770              BX       lr
;;;184    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      Device_Info
                  |L5.28|
                          DCD      bDeviceState

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;52     *******************************************************************************/
;;;53     void Set_System(void)
000000  b508              PUSH     {r3,lr}
;;;54     {
;;;55     #ifndef USE_STM3210C_EVAL
;;;56       GPIO_InitTypeDef GPIO_InitStructure;
;;;57     #endif /* USE_STM3210C_EVAL */
;;;58     
;;;59       /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration -----------------------------*/   
;;;60       /* RCC system reset(for debug purpose) */
;;;61       RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;62     
;;;63       /* Enable HSE */
;;;64       RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;65     
;;;66       /* Wait till HSE is ready */
;;;67       HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4923              LDR      r1,|L6.160|
000014  7008              STRB     r0,[r1,#0]
;;;68     
;;;69       if (HSEStartUpStatus == SUCCESS)
000016  4608              MOV      r0,r1
000018  7800              LDRB     r0,[r0,#0]  ; HSEStartUpStatus
00001a  2801              CMP      r0,#1
00001c  d127              BNE      |L6.110|
;;;70       {
;;;71         /* Enable Prefetch Buffer */
;;;72         FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
00001e  2010              MOVS     r0,#0x10
000020  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;73     
;;;74         /* Flash 2 wait state */
;;;75         FLASH_SetLatency(FLASH_Latency_2);
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       FLASH_SetLatency
;;;76      
;;;77         /* HCLK = SYSCLK */
;;;78         RCC_HCLKConfig(RCC_SYSCLK_Div1); 
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       RCC_HCLKConfig
;;;79       
;;;80         /* PCLK2 = HCLK */
;;;81         RCC_PCLK2Config(RCC_HCLK_Div1); 
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       RCC_PCLK2Config
;;;82     
;;;83         /* PCLK1 = HCLK/2 */
;;;84         RCC_PCLK1Config(RCC_HCLK_Div2);
000036  f44f6080          MOV      r0,#0x400
00003a  f7fffffe          BL       RCC_PCLK1Config
;;;85     
;;;86         /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;87         RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
00003e  f44f11e0          MOV      r1,#0x1c0000
000042  f44f3080          MOV      r0,#0x10000
000046  f7fffffe          BL       RCC_PLLConfig
;;;88     
;;;89         /* Enable PLL */ 
;;;90         RCC_PLLCmd(ENABLE);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       RCC_PLLCmd
;;;91     
;;;92         /* Wait till PLL is ready */
;;;93         while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000050  bf00              NOP      
                  |L6.82|
000052  2039              MOVS     r0,#0x39
000054  f7fffffe          BL       RCC_GetFlagStatus
000058  2800              CMP      r0,#0
00005a  d0fa              BEQ      |L6.82|
;;;94         {
;;;95         }
;;;96     
;;;97         /* Select PLL as system clock source */
;;;98         RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00005c  2002              MOVS     r0,#2
00005e  f7fffffe          BL       RCC_SYSCLKConfig
;;;99     
;;;100        /* Wait till PLL is used as system clock source */
;;;101        while(RCC_GetSYSCLKSource() != 0x08)
000062  bf00              NOP      
                  |L6.100|
000064  f7fffffe          BL       RCC_GetSYSCLKSource
000068  2808              CMP      r0,#8
00006a  d1fb              BNE      |L6.100|
00006c  e001              B        |L6.114|
                  |L6.110|
;;;102        {
;;;103        }
;;;104      }
;;;105      else
;;;106      { /* If HSE fails to start-up, the application will have wrong clock configuration.
;;;107           User can add here some code to deal with this error */    
;;;108    
;;;109        /* Go to infinite loop */
;;;110        while (1)
00006e  bf00              NOP      
                  |L6.112|
000070  e7fe              B        |L6.112|
                  |L6.114|
;;;111        {
;;;112        }
;;;113      }
;;;114    
;;;115      RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);    //‘ –ÌAFIO ±÷”
000072  2101              MOVS     r1,#1
000074  4608              MOV      r0,r1
000076  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;116    
;;;117      /* Enable USB_DISCONNECT GPIO clock */
;;;118      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
00007a  2101              MOVS     r1,#1
00007c  2008              MOVS     r0,#8
00007e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;119    
;;;120      /* Configure USB pull-up pin */
;;;121      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
000082  f44f4080          MOV      r0,#0x4000
000086  f8ad0000          STRH     r0,[sp,#0]
;;;122      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00008a  2003              MOVS     r0,#3
00008c  f88d0002          STRB     r0,[sp,#2]
;;;123      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000090  2014              MOVS     r0,#0x14
000092  f88d0003          STRB     r0,[sp,#3]
;;;124      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
000096  4669              MOV      r1,sp
000098  4802              LDR      r0,|L6.164|
00009a  f7fffffe          BL       GPIO_Init
;;;125    
;;;126    }
00009e  bd08              POP      {r3,pc}
;;;127    
                          ENDP

                  |L6.160|
                          DCD      HSEStartUpStatus
                  |L6.164|
                          DCD      0x40010c00

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;133    *******************************************************************************/
;;;134    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;135    {
;;;136    #ifdef STM32F10X_CL
;;;137      /* Select USBCLK source */
;;;138      RCC_OTGFSCLKConfig(RCC_OTGFSCLKSource_PLLVCO_Div3);
;;;139    
;;;140      /* Enable the USB clock */ 
;;;141      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_OTG_FS, ENABLE) ;
;;;142    #else 
;;;143      /* Select USBCLK source */
;;;144      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;145      
;;;146      /* Enable the USB clock */
;;;147      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  05c8              LSLS     r0,r1,#23
00000c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;148    #endif /* STM32F10X_CL */
;;;149    }
000010  bd10              POP      {r4,pc}
;;;150    
                          ENDP


                          AREA ||i.USART_Config||, CODE, READONLY, ALIGN=2

                  USART_Config PROC
;;;285    *******************************************************************************/
;;;286    bool USART_Config(void)
000000  b510              PUSH     {r4,lr}
;;;287    {
;;;288    
;;;289      /* set the Stop bit*/
;;;290      switch (linecoding.format)
000002  482f              LDR      r0,|L8.192|
000004  7900              LDRB     r0,[r0,#4]  ; linecoding
000006  b120              CBZ      r0,|L8.18|
000008  2801              CMP      r0,#1
00000a  d006              BEQ      |L8.26|
00000c  2802              CMP      r0,#2
00000e  d10e              BNE      |L8.46|
000010  e008              B        |L8.36|
                  |L8.18|
;;;291      {
;;;292        case 0:
;;;293          USART_InitStructure.USART_StopBits = USART_StopBits_1;
000012  2000              MOVS     r0,#0
000014  492b              LDR      r1,|L8.196|
000016  80c8              STRH     r0,[r1,#6]
;;;294          break;
000018  e00d              B        |L8.54|
                  |L8.26|
;;;295        case 1:
;;;296          USART_InitStructure.USART_StopBits = USART_StopBits_1_5;
00001a  f44f5040          MOV      r0,#0x3000
00001e  4929              LDR      r1,|L8.196|
000020  80c8              STRH     r0,[r1,#6]
;;;297          break;
000022  e008              B        |L8.54|
                  |L8.36|
;;;298        case 2:
;;;299          USART_InitStructure.USART_StopBits = USART_StopBits_2;
000024  f44f5000          MOV      r0,#0x2000
000028  4926              LDR      r1,|L8.196|
00002a  80c8              STRH     r0,[r1,#6]
;;;300          break;
00002c  e003              B        |L8.54|
                  |L8.46|
;;;301        default :
;;;302        {
;;;303          USART_Config_Default();
00002e  f7fffffe          BL       USART_Config_Default
;;;304          return (FALSE);
000032  2000              MOVS     r0,#0
                  |L8.52|
;;;305        }
;;;306      }
;;;307    
;;;308      /* set the parity bit*/
;;;309      switch (linecoding.paritytype)
;;;310      {
;;;311        case 0:
;;;312          USART_InitStructure.USART_Parity = USART_Parity_No;
;;;313          break;
;;;314        case 1:
;;;315          USART_InitStructure.USART_Parity = USART_Parity_Even;
;;;316          break;
;;;317        case 2:
;;;318          USART_InitStructure.USART_Parity = USART_Parity_Odd;
;;;319          break;
;;;320        default :
;;;321        {
;;;322          USART_Config_Default();
;;;323          return (FALSE);
;;;324        }
;;;325      }
;;;326    
;;;327      /*set the data type : only 8bits and 9bits is supported */
;;;328      switch (linecoding.datatype)
;;;329      {
;;;330        case 0x07:
;;;331          /* With this configuration a parity (Even or Odd) should be set */
;;;332          USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;333          break;
;;;334        case 0x08:
;;;335          if (USART_InitStructure.USART_Parity == USART_Parity_No)
;;;336          {
;;;337            USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;338          }
;;;339          else 
;;;340          {
;;;341            USART_InitStructure.USART_WordLength = USART_WordLength_9b;
;;;342          }
;;;343          
;;;344          break;
;;;345        default :
;;;346        {
;;;347          USART_Config_Default();
;;;348          return (FALSE);
;;;349        }
;;;350      }
;;;351    
;;;352      USART_InitStructure.USART_BaudRate = linecoding.bitrate;
;;;353      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;354      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;355     
;;;356      /* Configure and enable the USART */
;;;357      STM_EVAL_COMInit(COM1, &USART_InitStructure);
;;;358    
;;;359      return (TRUE);
;;;360    }
000034  bd10              POP      {r4,pc}
                  |L8.54|
000036  bf00              NOP                            ;294
000038  4821              LDR      r0,|L8.192|
00003a  7940              LDRB     r0,[r0,#5]            ;309  ; linecoding
00003c  b120              CBZ      r0,|L8.72|
00003e  2801              CMP      r0,#1                 ;309
000040  d006              BEQ      |L8.80|
000042  2802              CMP      r0,#2                 ;309
000044  d10e              BNE      |L8.100|
000046  e008              B        |L8.90|
                  |L8.72|
000048  2000              MOVS     r0,#0                 ;312
00004a  491e              LDR      r1,|L8.196|
00004c  8108              STRH     r0,[r1,#8]            ;312
00004e  e00d              B        |L8.108|
                  |L8.80|
000050  f44f6080          MOV      r0,#0x400             ;315
000054  491b              LDR      r1,|L8.196|
000056  8108              STRH     r0,[r1,#8]            ;315
000058  e008              B        |L8.108|
                  |L8.90|
00005a  f44f60c0          MOV      r0,#0x600             ;318
00005e  4919              LDR      r1,|L8.196|
000060  8108              STRH     r0,[r1,#8]            ;318
000062  e003              B        |L8.108|
                  |L8.100|
000064  f7fffffe          BL       USART_Config_Default
000068  2000              MOVS     r0,#0                 ;323
00006a  e7e3              B        |L8.52|
                  |L8.108|
00006c  bf00              NOP                            ;313
00006e  4814              LDR      r0,|L8.192|
000070  7980              LDRB     r0,[r0,#6]            ;328  ; linecoding
000072  2807              CMP      r0,#7                 ;328
000074  d002              BEQ      |L8.124|
000076  2808              CMP      r0,#8                 ;328
000078  d110              BNE      |L8.156|
00007a  e003              B        |L8.132|
                  |L8.124|
00007c  2000              MOVS     r0,#0                 ;332
00007e  4911              LDR      r1,|L8.196|
000080  8088              STRH     r0,[r1,#4]            ;332
000082  e00f              B        |L8.164|
                  |L8.132|
000084  480f              LDR      r0,|L8.196|
000086  8900              LDRH     r0,[r0,#8]            ;335  ; USART_InitStructure
000088  b918              CBNZ     r0,|L8.146|
00008a  2000              MOVS     r0,#0                 ;337
00008c  490d              LDR      r1,|L8.196|
00008e  8088              STRH     r0,[r1,#4]            ;337
000090  e003              B        |L8.154|
                  |L8.146|
000092  f44f5080          MOV      r0,#0x1000            ;341
000096  490b              LDR      r1,|L8.196|
000098  8088              STRH     r0,[r1,#4]            ;341
                  |L8.154|
00009a  e003              B        |L8.164|
                  |L8.156|
00009c  f7fffffe          BL       USART_Config_Default
0000a0  2000              MOVS     r0,#0                 ;348
0000a2  e7c7              B        |L8.52|
                  |L8.164|
0000a4  bf00              NOP                            ;333
0000a6  4806              LDR      r0,|L8.192|
0000a8  6800              LDR      r0,[r0,#0]            ;352  ; linecoding
0000aa  4906              LDR      r1,|L8.196|
0000ac  6008              STR      r0,[r1,#0]            ;352  ; USART_InitStructure
0000ae  2000              MOVS     r0,#0                 ;353
0000b0  8188              STRH     r0,[r1,#0xc]          ;353
0000b2  200c              MOVS     r0,#0xc               ;354
0000b4  8148              STRH     r0,[r1,#0xa]          ;354
0000b6  2000              MOVS     r0,#0                 ;357
0000b8  f7fffffe          BL       STM_EVAL_COMInit
0000bc  2001              MOVS     r0,#1                 ;359
0000be  e7b9              B        |L8.52|
;;;361    
                          ENDP

                  |L8.192|
                          DCD      linecoding
                  |L8.196|
                          DCD      USART_InitStructure

                          AREA ||i.USART_Config_Default||, CODE, READONLY, ALIGN=2

                  USART_Config_Default PROC
;;;252    *******************************************************************************/
;;;253    void USART_Config_Default(void)
000000  b510              PUSH     {r4,lr}
;;;254    {
;;;255      /* EVAL_COM1 default configuration */
;;;256      /* EVAL_COM1 configured as follow:
;;;257            - BaudRate = 115200 baud  
;;;258            - Word Length = 8 Bits
;;;259            - One Stop Bit
;;;260            - Parity Odd
;;;261            - Hardware flow control desabled
;;;262            - Receive and transmit enabled
;;;263      */
;;;264      USART_InitStructure.USART_BaudRate = 115200;
000002  f44f30e1          MOV      r0,#0x1c200
000006  4909              LDR      r1,|L9.44|
000008  6008              STR      r0,[r1,#0]  ; USART_InitStructure
;;;265      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00000a  2000              MOVS     r0,#0
00000c  8088              STRH     r0,[r1,#4]
;;;266      USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000e  80c8              STRH     r0,[r1,#6]
;;;267      USART_InitStructure.USART_Parity = USART_Parity_No;
000010  8108              STRH     r0,[r1,#8]
;;;268      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000012  8188              STRH     r0,[r1,#0xc]
;;;269      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000014  200c              MOVS     r0,#0xc
000016  8148              STRH     r0,[r1,#0xa]
;;;270    
;;;271      /* Configure and enable the USART */
;;;272      STM_EVAL_COMInit(COM1, &USART_InitStructure);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       STM_EVAL_COMInit
;;;273    
;;;274      /* Enable the USART Receive interrupt */
;;;275      USART_ITConfig(EVAL_COM1, USART_IT_RXNE, ENABLE);
00001e  2201              MOVS     r2,#1
000020  f2405125          MOV      r1,#0x525
000024  4802              LDR      r0,|L9.48|
000026  f7fffffe          BL       USART_ITConfig
;;;276    }
00002a  bd10              POP      {r4,pc}
;;;277    
                          ENDP

                  |L9.44|
                          DCD      USART_InitStructure
                  |L9.48|
                          DCD      0x40013800

                          AREA ||i.USART_To_USB_Send_Data||, CODE, READONLY, ALIGN=2

                  USART_To_USB_Send_Data PROC
;;;448    *******************************************************************************/
;;;449    void USART_To_USB_Send_Data(u8 data)
000000  4908              LDR      r1,|L10.36|
;;;450    {
;;;451      
;;;452      //if (linecoding.datatype == 7)
;;;453      //{
;;;454        //USART_Rx_Buffer[USART_Rx_ptr_in] = USART_ReceiveData(EVAL_COM1) & 0x7F;
;;;455      //}
;;;456      //else if (linecoding.datatype == 8)
;;;457      //{
;;;458        //USART_Rx_Buffer[USART_Rx_ptr_in] = USART_ReceiveData(EVAL_COM1);
;;;459        USART_Rx_Buffer[USART_Rx_ptr_in] = data;
000002  4a09              LDR      r2,|L10.40|
000004  6812              LDR      r2,[r2,#0]  ; USART_Rx_ptr_in
000006  5488              STRB     r0,[r1,r2]
;;;460      //}
;;;461      
;;;462      USART_Rx_ptr_in++;
000008  4907              LDR      r1,|L10.40|
00000a  6809              LDR      r1,[r1,#0]  ; USART_Rx_ptr_in
00000c  1c49              ADDS     r1,r1,#1
00000e  4a06              LDR      r2,|L10.40|
000010  6011              STR      r1,[r2,#0]  ; USART_Rx_ptr_in
;;;463      
;;;464      /* To avoid buffer overflow */
;;;465      if(USART_Rx_ptr_in == USART_RX_DATA_SIZE)
000012  4611              MOV      r1,r2
000014  6809              LDR      r1,[r1,#0]  ; USART_Rx_ptr_in
000016  f5b16f00          CMP      r1,#0x800
00001a  d101              BNE      |L10.32|
;;;466      {
;;;467        USART_Rx_ptr_in = 0;
00001c  2100              MOVS     r1,#0
00001e  6011              STR      r1,[r2,#0]  ; USART_Rx_ptr_in
                  |L10.32|
;;;468      }
;;;469    }
000020  4770              BX       lr
;;;470    
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      USART_Rx_Buffer
                  |L10.40|
                          DCD      USART_Rx_ptr_in

                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;223    *******************************************************************************/
;;;224    void USB_Cable_Config (FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;225    {
000002  4604              MOV      r4,r0
;;;226    #ifdef USE_STM3210C_EVAL  
;;;227      if (NewState != DISABLE)
;;;228      {
;;;229        USB_DevConnect();
;;;230      }
;;;231      else
;;;232      {
;;;233        USB_DevDisconnect();
;;;234      }
;;;235    #else /* USE_STM3210B_EVAL or USE_STM3210E_EVAL */
;;;236      if (NewState != DISABLE)
000004  b12c              CBZ      r4,|L11.18|
;;;237      {
;;;238        GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000006  f44f4180          MOV      r1,#0x4000
00000a  4805              LDR      r0,|L11.32|
00000c  f7fffffe          BL       GPIO_ResetBits
000010  e004              B        |L11.28|
                  |L11.18|
;;;239      }
;;;240      else
;;;241      {
;;;242        GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000012  f44f4180          MOV      r1,#0x4000
000016  4802              LDR      r0,|L11.32|
000018  f7fffffe          BL       GPIO_SetBits
                  |L11.28|
;;;243      }
;;;244    #endif /* USE_STM3210C_EVAL */
;;;245    }
00001c  bd10              POP      {r4,pc}
;;;246    
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
                          DCD      0x40010c00

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;190    *******************************************************************************/
;;;191    void USB_Interrupts_Config(void)
000000  b508              PUSH     {r3,lr}
;;;192    {
;;;193      NVIC_InitTypeDef NVIC_InitStructure;
;;;194    
;;;195      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;196    
;;;197    #ifdef STM32F10X_CL 
;;;198      /* Enable the USB Interrupts */
;;;199      NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
;;;200      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;201      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;202      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;203      NVIC_Init(&NVIC_InitStructure);
;;;204    #else
;;;205      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;206      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000010  2001              MOVS     r0,#1
000012  f88d0001          STRB     r0,[sp,#1]
;;;207      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2000              MOVS     r0,#0
000018  f88d0002          STRB     r0,[sp,#2]
;;;208      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2001              MOVS     r0,#1
00001e  f88d0003          STRB     r0,[sp,#3]
;;;209      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;210    #endif /* STM32F10X_CL */
;;;211    
;;;212      /* Enable USART Interrupt */
;;;213      NVIC_InitStructure.NVIC_IRQChannel = EVAL_COM1_IRQn;
000028  2025              MOVS     r0,#0x25
00002a  f88d0000          STRB     r0,[sp,#0]
;;;214      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  2000              MOVS     r0,#0
000030  f88d0001          STRB     r0,[sp,#1]
;;;215      NVIC_Init(&NVIC_InitStructure);
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       NVIC_Init
;;;216    }
00003a  bd08              POP      {r3,pc}
;;;217    
                          ENDP


                          AREA ||i.USB_Send_string||, CODE, READONLY, ALIGN=2

                  USB_Send_string PROC
;;;470    
;;;471     void USB_Send_string(u8* data_buffer)
000000  b510              PUSH     {r4,lr}
;;;472    {  
000002  4604              MOV      r4,r0
;;;473      count_in=63;
000004  203f              MOVS     r0,#0x3f
000006  4909              LDR      r1,|L13.44|
000008  6008              STR      r0,[r1,#0]  ; count_in
;;;474      UserToPMABufferCopy(data_buffer, ENDP1_TXADDR, count_in);
00000a  4608              MOV      r0,r1
00000c  6800              LDR      r0,[r0,#0]  ; count_in
00000e  b282              UXTH     r2,r0
000010  21c0              MOVS     r1,#0xc0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       UserToPMABufferCopy
;;;475      SetEPTxCount(ENDP1, count_in);
000018  4804              LDR      r0,|L13.44|
00001a  6800              LDR      r0,[r0,#0]  ; count_in
00001c  b281              UXTH     r1,r0
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       SetEPTxCount
;;;476      SetEPTxValid(ENDP1);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       SetEPTxValid
;;;477    
;;;478    }
00002a  bd10              POP      {r4,pc}
;;;479    
                          ENDP

                  |L13.44|
                          DCD      count_in

                          AREA ||i.USB_To_USART_Send_Data||, CODE, READONLY, ALIGN=2

                  USB_To_USART_Send_Data PROC
;;;368    *******************************************************************************/
;;;369    void USB_To_USART_Send_Data(uint8_t* data_buffer, uint8_t Nb_bytes)
000000  b570              PUSH     {r4-r6,lr}
;;;370    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;371      
;;;372      uint32_t i;
;;;373      
;;;374      for (i = 0; i < Nb_bytes; i++)
000006  2400              MOVS     r4,#0
000008  e00b              B        |L14.34|
                  |L14.10|
;;;375      {
;;;376        USART_SendData(EVAL_COM1, *(data_buffer + i));
00000a  5d29              LDRB     r1,[r5,r4]
00000c  4806              LDR      r0,|L14.40|
00000e  f7fffffe          BL       USART_SendData
;;;377        while(USART_GetFlagStatus(EVAL_COM1, USART_FLAG_TXE) == RESET); 
000012  bf00              NOP      
                  |L14.20|
000014  2180              MOVS     r1,#0x80
000016  4804              LDR      r0,|L14.40|
000018  f7fffffe          BL       USART_GetFlagStatus
00001c  2800              CMP      r0,#0
00001e  d0f9              BEQ      |L14.20|
000020  1c64              ADDS     r4,r4,#1              ;374
                  |L14.34|
000022  42b4              CMP      r4,r6                 ;374
000024  d3f1              BCC      |L14.10|
;;;378      }  
;;;379    }
000026  bd70              POP      {r4-r6,pc}
;;;380    
                          ENDP

                  |L14.40|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USART_InitStructure
                          %        16
                  USART_Rx_Buffer
                          %        2048

                          AREA ||.data||, DATA, ALIGN=2

                  USART_Rx_ptr_in
                          DCD      0x00000000
                  USART_Rx_ptr_out
                          DCD      0x00000000
                  USART_Rx_length
                          DCD      0x00000000
                  USB_Tx_State
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  count_in
                          DCD      0x00000000
                  HSEStartUpStatus
000014  00                DCB      0x00
