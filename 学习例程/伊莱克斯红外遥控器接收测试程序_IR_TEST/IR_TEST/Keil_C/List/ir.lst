C51 COMPILER V9.60.0.0   IR                                                                09/08/2023 13:17:57 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE IR
OBJECT MODULE PLACED IN ..\Output\ir.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil_v5\C51\BIN\C51.EXE ir.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE IN
                    -CDIR(..\FWLib\SC95F_Lib\inc;..\User;..\Project) DEFINE(SC95F8x1xB) DEBUG PRINT(..\List\ir.lst) TABS(2) OBJECT(..\Output\
                    -ir.obj)

line level    source

   1          #include "ir.h"
   2          #include "SC_Init.h"  // MCU initialization header file, including all firmware library header files
   3          #include "SC_it.h"
   4          #include "..\Drivers\SCDriver_list.h"
   5          #include "HeadFiles\SysFunVarDefine.h"
   6          #include "ir.h"
   7          #include "sc95f_usci0.h"
   8          
   9          //uint8_t firstbit;
  10          //uint8_t receive_statue;
  11          //extern uint8_t head705flag;
  12          uint32_t receive_buf[1] = {0};
  13          //uint8_t receive_buf[] = {0,0,0};
  14          uint8_t receive_bit;
  15          uint8_t send_buf[] = {0,0,0};
  16          uint8_t send_data[] = {0,0,0};
  17          extern uint8_t start_receiveflag;
  18          extern uint8_t head1080usflag;
  19          extern uint8_t after720usflag;
  20          extern uint8_t itcount;
  21          extern uint8_t sendendflag;
  22          
  23          
  24          /*********************************************************
  25          ***函数名：
  26          ***函数功能：IR信号接收
  27          ***参数：
  28          ***返回值：
  29          **********************************************************/
  30          void ir_receive()
  31          {
  32   1          uint8_t receive_data;
  33   1      
  34   1          receive_data = GPIO_ReadPin(GPIO1, GPIO_PIN_6);
  35   1          receive_buf[0] <<= 1;       //先左移一位，空出最低位
  36   1          
  37   1          /*将接收到的IR信号，高位存在缓冲区的高位（顺序没有变）*/
  38   1          if(receive_data)
  39   1          {
  40   2              receive_buf[0] |= 0x00000001;
  41   2          }
  42   1          else
  43   1          {
  44   2              receive_buf[0] &= 0xfffffffe;    //最低位为0
  45   2          }
  46   1      //      temp = receive_buf[0];
  47   1      //    for(i = 0;i <3 ; i--)
  48   1      //    {
  49   1      //       x = receive_data;
  50   1      //       bufvalue = temp;
  51   1      //       bufvalue <<= 1;
  52   1      //       receive_data = bufvalue&0x80;
  53   1      //      if(x)
C51 COMPILER V9.60.0.0   IR                                                                09/08/2023 13:17:57 PAGE 2   

  54   1      //      {
  55   1      //          bufvalue |= 0x01;    
  56   1      //      }
  57   1      //      else
  58   1      //      {
  59   1      //          bufvalue &= 0xfe;
  60   1      //      }
  61   1      //      receive_buf[i] = bufvalue;
  62   1      //      temp = receive_buf[i+1];      
  63   1      //    }
  64   1      }
  65            
  66          //uint16_t Send8DataTo9Data(uint8_t SendData)
  67          //{
  68          //  uint16_t giiSend9Data = 0;
  69          //  uint8_t i = 0,j=0;
  70          //    
  71          //  giiSend9Data = SendData;
  72          //  
  73          //  for (i=0;i<8;i++)
  74          //  {
  75          //    if (SendData&0x01)
  76          //    {
  77          //      j++;
  78          //    }
  79          //    SendData = ( SendData>> 1);
  80          //  }
  81          //  
  82          //  if((j%2)==0)
  83          //  {
  84          //    giiSend9Data |=0x100;
  85          //  }
  86          //  
  87          //  return giiSend9Data;
  88          //}
  89          
  90          
  91          /*********************************************************
  92          ***函数名：
  93          ***函数功能：红外数据接收
  94          ***参数：
  95          ***返回值：
  96          **********************************************************/
  97          void ir_receive_pocess()
  98          {
  99   1          uint32_t x,y,z;
 100   1          uint8_t i;
 101   1          uint8_t w,v;
 102   1        
 103   1          head1080usflag = 0;
 104   1          after720usflag = 0;
 105   1        
 106   1          if(receive_bit < 24)
 107   1          {
 108   2             ir_receive();   //将IR数据存起来
 109   2             receive_bit++;
 110   2          }
 111   1          else
 112   1          {
 113   2              receive_bit = 0;
 114   2              start_receiveflag = 0;
 115   2              itcount = 0;      //接收完成，中断次数清零
C51 COMPILER V9.60.0.0   IR                                                                09/08/2023 13:17:57 PAGE 3   

 116   2              x=y=z=receive_buf[0];    //将接收到的IR信号
 117   2              send_buf[0] = (u8)(x & 0xff);    //低8位
 118   2              send_buf[1] = (u8)(y >> 8);      //中8位
 119   2              send_buf[2] = (u8)(z >> 16);     //高8位
 120   2            
 121   2              /*将 低中高位的 3个8位的高低位倒序*/
 122   2              for(w=0;w<8;w++)
 123   2              {
 124   3                  for(v=0;v<3;v++)
 125   3                  {
 126   4                     send_data[v] >>= 1;    //空出最高位
 127   4                    
 128   4                     if(send_buf[v] & 0x80)
 129   4                     {
 130   5                         send_data[v] |= 0x80;
 131   5                     }
 132   4                     else
 133   4                     {
 134   5                         send_data[v] &= 0x7f;
 135   5                     }
 136   4                     send_buf[v] <<= 1;    //将原来的最高位移出去
 137   4                  }
 138   3            
 139   3              }
 140   2              
 141   2      /****************************************(串口发送)*****************************************/       
 142   2             for(i= 0 ; i < 3 ; i++)
 143   2             {  
 144   3                USCI0_UART_SendData8(send_data[i]);   
 145   3                 while (!sendendflag);
 146   3                 sendendflag = 0;
 147   3             }
 148   2             receive_buf[0] = 0;      //将接收缓冲区清零       
 149   2          }
 150   1      
 151   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    345    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     11       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
