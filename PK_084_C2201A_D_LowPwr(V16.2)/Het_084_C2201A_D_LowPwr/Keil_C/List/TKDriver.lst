C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TKDRIVER
OBJECT MODULE PLACED IN ..\Output\TKDriver.obj
COMPILER INVOKED BY: D:\Program Fails\Keil_v5\C51\BIN\C51.EXE ..\Drivers\TKDriver\C\TKDriver.C LARGE OBJECTADVANCED OPTI
                    -MIZE(9,SIZE) BROWSE INCDIR(..\FWLib\SC95F_Lib\inc;..\User;..\User\Funtion;..\SOC_DebugTouchKey_Lib;..\SOC_DebugTouchKey_
                    -Lib) DEFINE(SC95F8x1xB) DEBUG PRINT(..\List\TKDriver.lst) TABS(2) OBJECT(..\Output\TKDriver.obj)

line level    source

   1          //*************************************************************************************************
   2          //  Copyright (c)   ÉîÛÚÊÐÈüÔªÎ¢µç×ÓÓÐÏÞ¹«Ë¾
   3          //  ÎÄ¼þÃû³Æ  :  S_TouchKeyCFG.c
   4          //  ×÷Õß    : 
   5          //  Ä£¿é¹¦ÄÜ  :  ´¥¿Ø¼üÅäÖÃÎÄ¼þ
   6          //  °æ±¾    :
   7          //  ¸ü¸Ä¼ÇÂ¼  :
   8          //  ×¢ÒâÊÂÏî  :  ÓÃ»§ÐèÒªÅäÖÃµÄÎÄ¼þÔÚS_TouchKeyCFG.hÖÐ
   9          //  ¿â°æ±¾±ê¼Ç  : 
  10          //************************************************************************************************
  11          #include "S_TouchKeyCFG.h"
  12          #include "TKDriver.h"
  13          #include "stdio.h"
  14          #include "SC95F8x1xB_C.H"
  15          #include "HeadFiles\SysFunVarDefine.h"
  16          
  17          #define ScanTimeCon 3
  18          //*************************************************************************************
  19          //     ¼Ä´æÆ÷¶¨Òå
  20          //*************************************************************************************
  21          /*PSW*/
  22          sfr   TK_PSW      =   0xD0;             //³ÌÐò×´Ì¬×Ö
  23          sbit  TK_CY   =   TK_PSW^7;           //½øÎ»  
  24          
  25          #if defined(SC95F8x3x) || defined(SC92L853x) || defined(SC95F8x6x) || defined(SC95F8x1xB) 
  26          //sfr     BTMCON      =   0XFB;               //µÍÆµ¶¨Ê±Æ÷¿ØÖÆ¼Ä´æÆ÷
  27          #elif defined(SC92F848x) || defined(SC92F859x) 
              sfr     BTMCON      =   0XCE; 
              #endif
  30          
  31          
  32          sfr   TK_IE1      =   0xA9;             //ÖÐ¶Ï¿ØÖÆ¼Ä´æ
  33          /*system*/
  34          //sfr   PCON      =   0x87;             //µçÔ´¹ÜÀí¿ØÖÆ¼Ä´æÆ÷
  35          
  36          sfr   TKCR  = 0xE8;               //TouchKey¿ØÖÆ¼Ä´æÆ÷
  37          
  38          sfr   TKTMH = 0xE7;               //´¥Ãþ°´¼ü¶¨Ê±¼Ä´æÆ÷L
  39          sfr   TKTML = 0xE6;               //´¥Ãþ°´¼ü¶¨Ê±¼Ä´æÆ÷L
  40          sfr16   TKTM    =   0xE6;
  41          
  42          sfr   TKCNTH  = 0xE5;               //TouchKey¼ÆÊýÆ÷Öµ¸ß7Î»
  43          sfr   TKCNTL  = 0xE4;               //TouchKey¼ÆÊýÆ÷ÖµµÍ8Î»
  44          sfr16   TKCNT   =   0xE4;
  45          
  46          sfr   TKCFG2  = 0xE3;               //´¥Ãþ°´¼ü²Î¿¼µçÑ¹ÅäÖÃ¼Ä´æÆ÷
  47          sfr   TKCFG1  = 0xE2;               //TouchKeyÅäÖÃ¼Ä´æÆ÷2
  48          sfr   TKCFG0  = 0xE1;               //TouchKeyÅäÖÃ¼Ä´æÆ÷1
  49          
  50          /*TKCR*/
  51          sbit  ENTKS = TKCR^7;               //TouchKey¿ª¹ØµçÔ´
  52          sbit  TRIG  = TKCR^6;               //TouchKey´¥·¢¿ª¹Ø£ºÐ´1ÓÐÐ§£¬´¥·¢Ò»´ÎkeyÉ¨ÃèÖÜÆÚ
  53          sbit  TRIF  = TKCR^5;               //TouchKeyÖÐ¶Ï±êÖ¾
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 2   

  54          //===========================================================================
  55          //È«¾Ö±äÁ¿¶¨Òå
  56          unsigned  char  xdata   SOCAPI_TouchKeyStatus;  //API½Ó¿Ú×´Ì¬£ºbit7-Ò»ÂÖÉ¨ÃèÍê³É±êÖ¾  1:Íê³É  0£ºÎ´Íê³É
  57                                      //         bit6-Í¨µÀ´¥Ãþ¼ÆÊýÒç³ö±êÖ¾ 1:Òç³ö  0:Î´Òç³ö
  58          //===============================================================================
  59          //È«¾Ö±äÁ¿ÉùÃ÷£º¸ÃÇøÓò²»¿ÉÐÞ¸Ä
  60          unsigned  int   xdata   RawData [SOCAPI_SET_TOUCHKEY_TOTAL];      
  61          unsigned  int   data    BaseLine[SOCAPI_SET_TOUCHKEY_TOTAL];
  62          unsigned    int   xdata   FilterData[SOCAPI_SET_TOUCHKEY_TOTAL];                        
  63          unsigned  char    xdata   RestAreaCnt[SOCAPI_SET_TOUCHKEY_TOTAL];       
  64          unsigned  char    xdata   TouchCnt[SOCAPI_SET_TOUCHKEY_TOTAL];        
  65          unsigned  char    xdata   NoTouchCnt[SOCAPI_SET_TOUCHKEY_TOTAL];        
  66          unsigned  char  xdata   CurrentChannel[SOCAPI_SET_TOUCHKEY_TOTAL];                 
  67          unsigned    char    xdata       LowFingerDataCnt[SOCAPI_SET_TOUCHKEY_TOTAL];
  68          unsigned  char    xdata   FloatAreaCnt[SOCAPI_SET_TOUCHKEY_TOTAL]; 
  69          unsigned  char  xdata       BaseLineAdjusttmp[SOCAPI_SET_TOUCHKEY_TOTAL];   
  70          int                 xdata       DifferAccum[SOCAPI_SET_TOUCHKEY_TOTAL]; 
  71          char              xdata   SetNoiseThreshold;
  72          unsigned  char  xdata   ConfirmTouchCnt;
  73          unsigned  char  xdata   MultipleDealTpye = 0; 
  74          
  75          //×Ô¶¨Òå±äÁ¿
  76          unsigned  int   xdata       UpdateBaseLNum;         // µ¥¼ü³¤°´¼ÆÊýÆ÷
  77          unsigned  int   xdata       MultipleLNum;         // ¶à°´¼ü¸ÉÈÅ¼ÆÊý
  78          bit   WakeUp_Flag = 0;
  79          
  80          extern unsigned char gcSleepDelayTime;
  81          
  82          
  83          //Íâ²¿±äÁ¿½Ó¿Ú
  84          extern  unsigned  char  data    CurrentChannelMax;    //µ±Ç°Ñ¡ÖÐµÄkeysensorµÄ¸öÊý
  85          extern  bit  bMultiple; //¶à°´¼ü±êÖ¾
  86          extern  unsigned  int     xdata       ScanTime;
  87            
  88          extern  bit  GetIsNeedUpdateBaseline(void);
  89          extern  void SetNeedUpdateBaseline(void);
  90          extern  unsigned long int SensorKeyFlag(void);
  91          extern  void MultipleDeal(unsigned char CycleCnt);
  92          extern  void FilterDataDeal(unsigned char i);
  93          extern  void TouchKey_Service(void);
  94          void  TKSleepMode(void);
  95          extern void ADC_Process(void);
  96          
  97          /***************µ¯»É¿â¶ÀÓÐ***************/
  98          #define   SOCAPI_SET_CS_FUNCTION            1   //0:±íÊ¾²»½øÐÐCS²âÊÔ,1: ±íÊ¾½øÐÐCS²âÊÔ,Ä¬ÈÏ0
  99          #define   SOCAPI_INHIBITION_ZONE              8   //ÒÖÖÆÇø¼ä%£¬ÉèÖÃ·¶Î§5-10£¬Ä¬ÈÏ7,¼´£¨7*10£©%=70% £¬Á¬Ë®Ê±¼Ó´ó¸Ã
             -²ÎÊý,¶Ô½²»úÉèÖÃÐ¡
 100          #define   SOCAPI_MAX_KEY_MUTIPLE            300   //¶àÉÙ´Î¸ÉÈÅ¸üÐÂ»ùÏß£¬Ä¬ÈÏ300*5=1500
 101          #define   SOCAPI_MAX_KEY_NUM_INVALID          3   //Ç¿ÖÆ¸üÐÂ»ùÏß°´¼üÏÞÖÆ¸öÊý£¬Ä¬ÈÏ3
 102          /****************************************/
 103          
 104          #define     AppType               0
 105          #define     IsDoubleKey           1
 106          #define     AirSeparationDistance       2
 107          #define     CONFIRMTOUCHCNT                 3
 108          #define     INIT_AUTO_UPDATE_TIME       4
 109          #define     SET_KEY_CONTI_TIME              5  
 110          #define     SET_SYNC_UPDATE         6
 111          #define     SET_UPDATE_SPEED        7 
 112          #define     AUTO_UPDATE_TIME            8
 113          #define     FilteredKValue          9
 114          #define     SET_ANTIJAM             10
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 3   

 115          #define     BAUD                    11
 116          #define     DwellTime               12
 117          #define     SaveTime                13
 118          #define     NOISE                   16
 119          
 120          #define     SET_TOUCH_FREQ          0
 121          #define     SET_RESOLUTION          1
 122          #define     SET_GAIN_CFG          2
 123          #define     SCANTIME            3
 124          #define     SET_ICHA            4
 125          #define     FINGER_THRESHOLD_H          6
 126          #define     FINGER_THRESHOLD_L          7
 127          
 128          //**********************************************************************************  
 129          //                µÍ¹¦ºÄÉèÖÃ                //
 130          //**********************************************************************************
 131          
 132          #define     TK_LowPowerMode                
 133          
 134          #ifdef  TK_LowPowerMode
 135          
 136          #define   BTM_TIMEBASE_15600US     0X00   //µÍÆµÊ±ÖÓÖÐ¶ÏÊ±¼äÎª15.6MS
 137          #define   BTM_TIMEBASE_31300US     0X01   //µÍÆµÊ±ÖÓÖÐ¶ÏÊ±¼äÎª31.3MS
 138          #define   BTM_TIMEBASE_62500US     0X02   //µÍÆµÊ±ÖÓÖÐ¶ÏÊ±¼äÎª62.5MS
 139          #define   BTM_TIMEBASE_125MS       0X03   //µÍÆµÊ±ÖÓÖÐ¶ÏÊ±¼äÎª125MS
 140          #define   BTM_TIMEBASE_250MS       0X04   //µÍÆµÊ±ÖÓÖÐ¶ÏÊ±¼äÎª250MS
 141          #define   BTM_TIMEBASE_500MS       0X05   //µÍÆµÊ±ÖÓÖÐ¶ÏÊ±¼äÎª500MS
 142          #define   BTM_TIMEBASE_1S          0X06   //µÍÆµÊ±ÖÓÖÐ¶ÏÊ±¼äÎª1S
 143          #define   BTM_TIMEBASE_2S          0X07   //µÍÆµÊ±ÖÓÖÐ¶ÏÊ±¼äÎª2S
 144          #define   BTM_TIMEBASE_4S          0X08   //µÍÆµÊ±ÖÓÖÐ¶ÏÊ±¼äÎª4S
 145          
 146          #include <intrins.h>
 147          
 148          #define      WakeUpKeyNum                      WakeUpKeyNum_Set                    //µÍ¹¦ºÄÄ£Ê½ÏÂÉ¨Ãè°´¼ü¸
             -öÊý     
 149          #define      WakeUpKeyChannel                  WakeUpKeyChannel_Set                //µÍ¹¦ºÄÏÂÉ¨Ãè°´¼üµÄ¶ÔÓ
             -¦Í¨µÀ
 150          #define      TK_SeepTimervSetting              TK_SeepTimervSetting_Set            //µÍ¹¦ºÄÏÂ°´¼üÖ®¼äµÄÉ¨Ã
             -è¼ä¸ô
 151          #define      TK_WakeUpConfirmTouchCnt          TK_WakeUpConfirmTouchCnt_Set      //µÍ¹¦ºÄÏÂÈ·ÈÏ°´¼ü´ÎÊý
 152          
 153          #if TK_SeepTimervSetting == BTM_TIMEBASE_4S             //µÍ¹¦ºÄÏÂ»ùÏß¸üÐÂ¼ä¸ô¶¨Òå
                #define  BaselineUpdateCnt  1                   
              #elif TK_SeepTimervSetting == BTM_TIMEBASE_2S             
                #define  BaselineUpdateCnt  3
              #elif TK_SeepTimervSetting == BTM_TIMEBASE_1S             
                #define  BaselineUpdateCnt  6
              #elif TK_SeepTimervSetting == BTM_TIMEBASE_500MS          
                #define  BaselineUpdateCnt  12
              #elif TK_SeepTimervSetting == BTM_TIMEBASE_250MS           
                #define  BaselineUpdateCnt  24
              #elif TK_SeepTimervSetting == BTM_TIMEBASE_125MS
 164            #define  BaselineUpdateCnt  48
 165          #elif TK_SeepTimervSetting == BTM_TIMEBASE_62500US
                #define  BaselineUpdateCnt  96
              #elif TK_SeepTimervSetting == BTM_TIMEBASE_31300US
                #define  BaselineUpdateCnt  192
              #elif TK_SeepTimervSetting == BTM_TIMEBASE_15600US
                #define  BaselineUpdateCnt  384                 
              #endif
 172          
 173          bit  LowPowerScan_Flag = 0;                                         //µÍ¹¦ºÄÉ¨Ãè±êÖ¾
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 4   

 174          bit  SingleKeyFastScan_Flag = 0;                                    //µ¥°´¼ü¿ìËÙÉ¨Ãè±êÖ¾
 175          bit  BTM_WakeUpFlag =0;                       //BTM»½ÐÑ±êÖ¾Î»
 176          bit  Touch_WakeUpFlag=0;                      //°´¼ü»½ÐÑ±êÖ¾Î»
 177          
 178          unsigned    char    xdata       WakeUpKey_List[WakeUpKeyNum];
 179          unsigned  char  xdata       WakeUpThenScanCount = 0; 
 180          unsigned  int   WakeUpNum;                      //»½ÐÑ´ÎÊý¼ÆÊý--ÓÃÓÚµÍ¹¦ºÄÏÂ¸üÐÂ»ùÏß
 181          unsigned  char  data WakeUpKeyValue;            //==WakeUpKey_List[WakeUpKey_Index]
 182          unsigned  int   ScanTimeTemp0;                  //==ScanTime
 183          
 184          //**********************************************************************************  
 185          //                Ãæ°åÑ¡ÔñÉèÖÃ                //
 186          //**********************************************************************************
 187          
 188          //unsigned char  Sensitivity_4mmValue[1][8]={0x03,0x2e,0x04,0x0a,0x21,0x05,0x00,0x9c,};  //4MM ¸Ö»¯²£Á§ 01
 189          //unsigned char  Sensitivity_4mmValue[1][8]={0x03,0x2e,0x04,0x08,0x22,0x06,0x00,0xad,};  //4MM ¸Ö»¯²£Á§ 02
 190          //unsigned char  Sensitivity_8mmValue[1][8]={0x03,0x2e,0x04,0x1a,0x22,0x05,0x00,0x98,}; // 8mm Î¢¾§²£Á§
 191          //unsigned char  Sensitivity_4mmValue[1][8]={0x03,0x2e,0x04,0x0e,0x22,0x05,0x01,0x5f,};  //4MM ¸Ö»¯²£Á§ 06
             -28
 192          //unsigned char  Sensitivity_8mmValue[1][8]={0x03,0x2e,0x04,0x10,0x22,0x05,0x00,0xc7,};  // 8mm Î¢¾§²£Á§
 193          //unsigned char  Sensitivity_4mmValue[1][8]={0x03,0x32,0x04,0x08,0x23,0x05,0x01,0x2c,};       //12c = 300
 194          
 195          
 196          unsigned char  Sensitivity_4mmValue[1][8]={0x03,0x32,0x04,0x08,0x23,0x05,0x00,0xc6,};       //c6 = 198
 197          unsigned char  Sensitivity_8mmValue[1][8]={0x03,0x2e,0x04,0x10,0x22,0x05,0x00,0x8d,};       // 8mm Î¢¾§²£Á
             -§7c
 198          
 199          extern void Time_Process(void);
 200          extern void SleepLED_Process(void);
 201          extern void WakeAutoSleep(void);
 202          
 203          void Set_Cfg()
 204          { 
 205   1        unsigned char i;
 206   1          if(P31==0)       //½ÓÉÏ
 207   1          {
 208   2            for(i=0;i<8;i++)
 209   2            {
 210   3              TKChannelCfg[0][i]=Sensitivity_4mmValue[0][i];
 211   3            }     
 212   2          }
 213   1          else
 214   1          {
 215   2            for(i=0;i<8;i++)
 216   2            {
 217   3              TKChannelCfg[0][i]=Sensitivity_8mmValue[0][i];
 218   3            }         
 219   2          }
 220   1      }
 221          
 222          
 223          //**********************************************************************************
 224          
 225          /**************************************************
 226          *º¯ÊýÃû³Æ£ºvoid BtmInit(void) 
 227          *º¯Êý¹¦ÄÜ£º
 228          *Èë¿Ú²ÎÊý£ºvoid 
 229          *³ö¿Ú²ÎÊý£ºvoid
 230          **************************************************/
 231          void BTM_Init(void)
 232          {
 233   1          BTMCON = BTMCON & 0XF0 | TK_SeepTimervSetting;
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 5   

 234   1          BTMCON |= 0X80;
 235   1          TK_IE1 |= 0X04;
 236   1      }
 237          
 238          /**************************************************
 239          *º¯ÊýÃû³Æ£ºvoid BtmInit(void) interrupt 0
 240          *º¯Êý¹¦ÄÜ£ºBtmÖÐ¶Ï·þÎñº¯Êý
 241          *Èë¿Ú²ÎÊý£ºvoid 
 242          *³ö¿Ú²ÎÊý£ºvoid
 243          **************************************************/
 244          void BtmInit(void) interrupt  9
 245          {
 246   1         BTM_WakeUpFlag = 1;
 247   1      
 248   1      }
 249          #endif
 250          
 251          //**********************************************************************************  
 252          //                  º¯Êý½Ó¿Úµ÷ÓÃ²¿·Ö                  //
 253          //**********************************************************************************
 254          /**************************************************
 255          *º¯ÊýÃû³Æ£ºunsigned int SetOneKeyPushResetTime(void) 
 256          *º¯Êý¹¦ÄÜ£º°´¼ü×î³¤µÄÊä³öÊ±¼ä
 257          *Èë¿Ú²ÎÊý£ºvoid
 258          *³ö¿Ú²ÎÊý£ºunsigned int SOCAPI_SET_KEY_CONTI_TIME
 259          *±¸×¢  £ºÕâ¸ö·µ»ØÖµµÄÉèÖÃ£¬ ÊÇ¸ù¾ÝÓÐ¶à³¤Ê±¼äÆô¶¯TouchKeyRestart£¨£©
 260          ÀýÈç10ms Æô¶¯Ò»´Î£¬ ÄÇSOCAPI_SET_KEY_CONTI_TIME*10ms£¬³¬¹ýÊ±¼äºó´Ë°´¼üÎÞÐ§¡£
 261          **************************************************/
 262          unsigned int SetOneKeyPushResetTime(void)   
 263          {   
 264   1        return  TKCFG[SET_KEY_CONTI_TIME];
 265   1      }
 266          
 267          /**************************************************
 268          *º¯ÊýÃû³Æ£ºint  GetBaselineUpdateThreshold(void)
 269          *º¯Êý¹¦ÄÜ£º¸üÐÂËÙ¶È 
 270          *Èë¿Ú²ÎÊý£ºvoid
 271          *³ö¿Ú²ÎÊý£ºint 
 272          *±¸×¢  £º
 273          **************************************************/
 274          int  GetBaselineUpdateThreshold(void)
 275          {
 276   1        return TKCFG[SET_UPDATE_SPEED]; 
 277   1      }
 278          
 279          /**************************************************
 280          *º¯ÊýÃû³Æ£ºunsigned char GetInitAutoUpdateTime(void)
 281          *º¯Êý¹¦ÄÜ£º³õÊ¼»¯×Ô¶¯Ð£×¼´ÎÊý
 282          *Èë¿Ú²ÎÊý£ºvoid
 283          *³ö¿Ú²ÎÊý£ºunsigned  char 
 284          *±¸×¢  £º
 285          **************************************************/
 286          unsigned char GetInitAutoUpdateTime(void)
 287          {
 288   1        return  TKCFG[INIT_AUTO_UPDATE_TIME];
 289   1      }
 290          /**************************************************
 291          *º¯ÊýÃû³Æ£º char GetCsFunction(void)
 292          *º¯Êý¹¦ÄÜ£º½øÐÐCS ²âÊÔ
 293          *Èë¿Ú²ÎÊý£ºvoid
 294          *³ö¿Ú²ÎÊý£ºchar SOCAPI_SET_CS_FUNCTION
 295          *±¸×¢  £º
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 6   

 296          **************************************************/
 297          char GetCsFunction(void)
 298          {
 299   1        return SOCAPI_SET_CS_FUNCTION; 
 300   1      }
 301          /**************************************************
 302          *º¯ÊýÃû³Æ£ºint  GetCurrFingerValue(unsigned char i)
 303          *º¯Êý¹¦ÄÜ£º»ñÈ¡µ±Ç°µÄfinger Öµ
 304          *Èë¿Ú²ÎÊý£ºunsigned char
 305          *³ö¿Ú²ÎÊý£ºint 
 306          *±¸×¢  £º
 307          **************************************************/
 308          unsigned int   GetCurrFingerValue(unsigned char i)
 309          { 
 310   1        return  TKChannelCfg[i][FINGER_THRESHOLD_H]*256+TKChannelCfg[i][FINGER_THRESHOLD_L] ;
 311   1      }
 312          
 313          /**************************************************
 314          *º¯ÊýÃû³Æ£ºunsigned char  GetScanTimeValue(unsigned char i)
 315          *º¯Êý¹¦ÄÜ£º»ñÈ¡µ±Ç°Í¨µÀµÄÉ¨ÃèÊ±¼ä
 316          *Èë¿Ú²ÎÊý£ºunsigned char
 317          *³ö¿Ú²ÎÊý£ºunsigned char 
 318          *±¸×¢  £º
 319          **************************************************/
 320          unsigned char  GetScanTimeValue(unsigned char i)
 321          { 
 322   1        return TKChannelCfg[i][SCANTIME];
 323   1      }
 324          /**************************************************
 325          *º¯ÊýÃû³Æ£ºunsigned char IsDoubleKeyOrSlideKey(void)
 326          *º¯Êý¹¦ÄÜ£º¼ì²âÊÇ·ñÊÇµ¯»É»¬Ìõ»òÕßË«¼ü
 327          *Èë¿Ú²ÎÊý£ºvoid
 328          *³ö¿Ú²ÎÊý£ºunsigned char 
 329          *±¸×¢  £º
 330          **************************************************/
 331          unsigned char IsDoubleKeyOrSlideKey(void)
 332          {
 333   1          return TKCFG[IsDoubleKey];
 334   1      }
 335          /**************************************************
 336          *º¯ÊýÃû³Æ£ºunsigned char  GetBaseLineAdjustValue(unsigned char i)
 337          *º¯Êý¹¦ÄÜ£º»ñÈ¡µ±Ç°Í¨µÀµÄ»ùÏßµ÷Õû
 338          j
 339          *Èë¿Ú²ÎÊý£ºunsigned char
 340          *³ö¿Ú²ÎÊý£ºunsigned char 
 341          *±¸×¢  £º
 342          **************************************************/
 343          unsigned char  GetBaseLineAdjustValue(unsigned char i)
 344          { 
 345   1           return BaseLineAdjusttmp[i]; 
 346   1      }
 347          /**************************************************
 348          *º¯ÊýÃû³Æ£ºunsigned char GetUpConfirmCnt(void)
 349          *º¯Êý¹¦ÄÜ£º¼ì²â°´¼üµ¯Æð´ÎÊý
 350          *Èë¿Ú²ÎÊý£ºvoid
 351          *³ö¿Ú²ÎÊý£º·µ»Ø°´¼üµ¯ÆðÈ·ÈÏ´ÎÊý 
 352          *±¸×¢  £º
 353          **************************************************/
 354          unsigned char GetUpConfirmCnt(void)
 355          {
 356   1        return ConfirmTouchCnt>>1;
 357   1      }
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 7   

 358          /**************************************************
 359          *º¯ÊýÃû³Æ£ºunsigned char GetTKYzCnt(void)
 360          *º¯Êý¹¦ÄÜ£º»ñÈ¡°´¼üÒÖÖÆÈ·ÈÏ´ÎÊý
 361          *Èë¿Ú²ÎÊý£ºvoid
 362          *³ö¿Ú²ÎÊý£º·µ»ØÒÖÖÆ´ÎÊý 
 363          *±¸×¢  £º
 364          **************************************************/
 365          
 366          unsigned char GetTKYzCnt(void)
 367          {
 368   1        return (ConfirmTouchCnt/3);
 369   1      }
 370          
 371          /**************************************************
 372          *º¯ÊýÃû³Æ£ºint GetTKYzThreshold(unsigned char i)
 373          *º¯Êý¹¦ÄÜ£º»ñÈ¡°´¼üÒÖÖÆÇø¼ä
 374          *Èë¿Ú²ÎÊý£ºunsigned char i
 375          *³ö¿Ú²ÎÊý£º·µ»ØÒÖÖÆÇø¼ä
 376          *±¸×¢  £º
 377          **************************************************/
 378          int GetTKYzThreshold(unsigned char i)
 379          { 
 380   1        unsigned int SetFingerThresholdtmp; 
 381   1        
 382   1        SetFingerThresholdtmp = GetCurrFingerValue(i); 
 383   1          SetFingerThresholdtmp = SetFingerThresholdtmp*SOCAPI_INHIBITION_ZONE/10;
 384   1      
 385   1        return SetFingerThresholdtmp;
 386   1      }
 387          /**************************************************
 388          *º¯ÊýÃû³Æ£ºvoid CurrentSensorChoose(void)
 389          *º¯Êý¹¦ÄÜ£ºµ±Ç°Í¨µÀÑ¡Ôñ
 390          *Èë¿Ú²ÎÊý£ºvoid
 391          *³ö¿Ú²ÎÊý£ºvoid
 392          *±¸×¢  £º
 393          **************************************************/
 394          void CurrentSensorChoose(void)
 395          {
 396   1        unsigned char   i = 0;
 397   1        unsigned char   Ctk_Channel_mark = 0;
 398   1        unsigned char   WakeUpKey_Channel_mark = 0;
 399   1        unsigned long int CurrentSensorKey = 0 ; 
 400   1        
 401   1        CurrentSensorKey = SOCAPI_SET_TOUCHKEY_CHANNEL; 
 402   1          
 403   1        for(i=0;i<31;i++)
 404   1        {
 405   2          CurrentSensorKey=CurrentSensorKey>>1;
 406   2          if(TK_CY)
 407   2          {
 408   3            CurrentChannel[Ctk_Channel_mark] = i;           //Ñ¡Ôñ´¥Ãþµ±Ç°µÄÍ¨µÀ
 409   3                  #ifdef  TK_LowPowerMode
 410   3            if(WakeUpKey_Channel_mark<WakeUpKeyNum)
 411   3                  {
 412   4                      if((WakeUpKeyChannel&((unsigned long int)1<<i)))
 413   4                      {
 414   5                          WakeUpKey_List[WakeUpKey_Channel_mark++] = Ctk_Channel_mark;
 415   5                      }
 416   4                  }
 417   3                  #endif
 418   3            Ctk_Channel_mark++;
 419   3            if(Ctk_Channel_mark >= SOCAPI_SET_TOUCHKEY_TOTAL)
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 8   

 420   3              break;
 421   3          }   
 422   2        }
 423   1        CurrentChannelMax = Ctk_Channel_mark;             //µ±Ç°Ñ¡ÔñµÄ°´¼üÊý 
 424   1      }
 425          
 426          /**************************************************
 427          *º¯ÊýÃû³Æ£ºunsigned char  GetCfgMsg(unsigned char i)
 428          *º¯Êý¹¦ÄÜ£º»ñÈ¡Touch KEY ÅäÖÃÐÅÏ¢
 429          *Èë¿Ú²ÎÊý£ºvoid
 430          *³ö¿Ú²ÎÊý£ºint 
 431          *±¸×¢  £º
 432          **************************************************/
 433          unsigned char  GetCfgMsg(unsigned char i)
 434          {
 435   1        switch(i)
 436   1        { 
 437   2           case 0:  return TKChannelCfg[0][SET_TOUCH_FREQ];
 438   2           case 1:  return TKChannelCfg[0][SET_RESOLUTION];
 439   2           case 2:  return TKChannelCfg[0][SET_GAIN_CFG];
 440   2           case 3:  return GetBaseLineAdjustValue(0); //TKChannelCfg[0][SET_GAIN_CFG];
 441   2           case 4:  return TKCFG[SET_ANTIJAM];
 442   2           default:return 0;    
 443   2        }
 444   1      }
 445          
 446          /**************************************************
 447          *º¯ÊýÃû³Æ£ºvoid CurrentSensorChoose(void)
 448          *º¯Êý¹¦ÄÜ£º³õÊ¼»¯TK¼Ä´æÆ÷
 449          *Èë¿Ú²ÎÊý£ºvoid
 450          *³ö¿Ú²ÎÊý£ºvoid
 451          *±¸×¢  £º
 452          **************************************************/
 453          void TouchKeyCFGInit(void)
 454          {
 455   1        unsigned char   i;
 456   1        ConfirmTouchCnt = TKCFG[CONFIRMTOUCHCNT];
 457   1        SetNoiseThreshold = TKCFG[NOISE];
 458   1        CurrentSensorChoose(); 
 459   1        for(i=0;i<CurrentChannelMax;i++)
 460   1        {
 461   2          BaseLineAdjusttmp[i] =TKChannelCfg[i][SET_ICHA];; 
 462   2        } 
 463   1        UpdateBaseLNum = 0;
 464   1          #ifdef  TK_LowPowerMode
 465   1          BTM_Init();
 466   1          #endif 
 467   1      }
 468          
 469          /**************************************************
 470          *º¯ÊýÃû³Æ£ºunsigned int TouchKeyScan(void)
 471          *º¯Êý¹¦ÄÜ£º¼ì²â°´¼ü½Ó¿Ú
 472          *Èë¿Ú²ÎÊý£ºvoid
 473          *³ö¿Ú²ÎÊý£º°´¼üÍ¨µÀ£¬ ·µ»ØµÄÊÇÒ»¸öint , Í¨µÀÊý
 474          *±¸×¢  £º1,  µ÷ÓÃ´¥¿Ø¿â¼ì²âº¯ÊýSensorKeyFlag()
 475                 2,  ·ÖÎöµÃ³ö16¸öÍ¨µÀ£¬ÄÄ¸öÍ¨µÀÓÐ°´ÏÂ£¬°´ÏÂbit Î»ÉèÖÃÎª1£¬·ñÔòÎª0
 476                 3,  ¼ì²âÊÇ·ñÐèÒªÁ¢¼´¸üÐÂbaseline:  ´óÓÚMAX_KEY_RESET_BASELINE ¸ö°´¼ü°´ÏÂÊ±Á¢¼´¸üÐÂbaseline
 477                 4,  Ë«¼ü»òÕßµ¥¼ü°´ÏÂÊ±£¬ Ê±¼ä´óÓÚSetOneKeyPushResetTime()½á¹ûÊ±¸üÐÂbaseline 
 478          **************************************************/
 479          unsigned char OffHandCount = 0;
 480          unsigned int  NumCount = 0;
 481          unsigned long int TouchKeyScan(void)
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 9   

 482          {
 483   1        unsigned char t;
 484   1          unsigned char MultipleCnt = 0;//°´¼ü¼ÆÊý
 485   1        unsigned long int Keyvalue = 0; 
 486   1        unsigned long int KeyData = 0;  
 487   1        int WakeupDiffData = 0; 
 488   1        int WakeupSetFingerThresholdtmp;
 489   1        
 490   1      
 491   1        if(WakeUp_Flag == 0)
 492   1        {
 493   2          if(GetIsNeedUpdateBaseline() == 0)        //¼ì²âÊÇ·ñÐèÒª¸üÐÂbaseline 
 494   2          {
 495   3            Keyvalue = SensorKeyFlag();         //SensorÅÐ¶Ï, ÕâÀïÈç¹ûbMultiple = 1 ±íÊ¾ÖÐ¼äÓÐ¸ÉÈÅ   //·ÖÎö°´¼ü£¬µÃ³ö±ê×
             -¼µÄ16Í¨µÀbit Î»                                      
 496   3            for(t=0;t<CurrentChannelMax;t++)
 497   3            {
 498   4              Keyvalue = Keyvalue>>1;
 499   4              if(TK_CY)
 500   4              {
 501   5                KeyData |= ((unsigned long int)0x01 << (CurrentChannel[t]));              
 502   5                MultipleCnt++;              
 503   5              }
 504   4            }                
 505   3            if(MultipleCnt >= 2)              //½øÈë¶à°´¼ü´¦Àí
 506   3            {     
 507   4              bMultiple = 1;      
 508   4              if(MultipleCnt >= SOCAPI_MAX_KEY_NUM_INVALID)
 509   4              {
 510   5                SetNeedUpdateBaseline();        // Á¢¼´¸üÐÂbaseline ,ÀýÈçÑÇ¿ËÁ¦°å¸ÇÉÏÈ¥
 511   5              }
 512   4              else
 513   4              {         
 514   5                if(IsDoubleKeyOrSlideKey())
 515   5                {
 516   6                  bMultiple = 0;
 517   6                }          
 518   5              }     
 519   4            }     
 520   3        
 521   3            if(bMultiple == 0)                //½øÈë°´¼üÅÐ¶Ï
 522   3            {   
 523   4              if(KeyData != 0x0)                //µ¥¸ö°´¼ü´ïµ½¶à³¤Ê±¼ä¾Íupdate baseline ,ËÉÊÖ¼ì²â
 524   4              {     
 525   5                UpdateBaseLNum++; 
 526   5              }
 527   4              else  
 528   4              {
 529   5                UpdateBaseLNum = 0;   
 530   5              } 
 531   4            } 
 532   3            else
 533   3            {   
 534   4                //¿¼ÂÇ»ùÏß¸üÐÂ    
 535   4              MultipleLNum++; 
 536   4              KeyData = 0x00;
 537   4            }
 538   3        
 539   3            if(UpdateBaseLNum > SetOneKeyPushResetTime()) //°´¼ü³¬³ö×î³¤Êä³öÊ±¼ä¸üÐÂ»ùÏß
 540   3            {
 541   4              SetNeedUpdateBaseline(); 
 542   4              UpdateBaseLNum = 0;
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 10  

 543   4            }
 544   3                
 545   3            if(MultipleLNum >SOCAPI_MAX_KEY_MUTIPLE)    //¸ÉÈÅ¼ÆÊý´óÓÚ×î´ó¼ÆÊý¸üÐÂ»ùÏß
 546   3            {
 547   4              SetNeedUpdateBaseline(); 
 548   4              MultipleDealTpye = 1; 
 549   4              MultipleLNum = 0;
 550   4            }  
 551   3          }     
 552   2          else
 553   2          {
 554   3            MultipleDeal(TKCFG[AUTO_UPDATE_TIME]);      //»ùÏß¸´Î»´¦Àí
 555   3          }
 556   2        }
 557   1        else
 558   1        {
 559   2              #ifdef  TK_LowPowerMode
 560   2          
 561   2          if(Touch_WakeUpFlag==1)
 562   2          {
 563   3            KeyData |= ((unsigned long int)0x01 << (CurrentChannel[WakeUpKeyValue]));
 564   3      
 565   3            WakeupDiffData = RawData[WakeUpKeyValue]-BaseLine[WakeUpKeyValue];
 566   3            WakeupSetFingerThresholdtmp = GetCurrFingerValue(WakeUpKeyValue);
 567   3      
 568   3            if(WakeupDiffData <= (WakeupSetFingerThresholdtmp-((WakeupSetFingerThresholdtmp)>>2)))
 569   3            { 
 570   4              NumCount=0;
 571   4              if(++OffHandCount>5)
 572   4              {
 573   5                OffHandCount = 0;
 574   5                WakeUp_Flag = 0;
 575   5                Touch_WakeUpFlag=0;
 576   5                KeyData = 0;
 577   5              }
 578   4              for(t=0;t<CurrentChannelMax;t++)
 579   4              {
 580   5                FilterDataDeal(t);
 581   5                if(!WakeUp_Flag)
 582   5                {
 583   6                  if(WakeUpKeyValue == t)
 584   6                  continue;
 585   6                  BaseLine[t] = RawData[t]; 
 586   6                }
 587   5              }
 588   4                
 589   4            }
 590   3            else
 591   3            {
 592   4              OffHandCount=0;
 593   4              if(++NumCount > SetOneKeyPushResetTime()) //°´¼ü³¬³ö×î³¤Êä³öÊ±¼ä¸üÐÂ»ùÏß
 594   4              {
 595   5                SetNeedUpdateBaseline(); 
 596   5                NumCount = 0;
 597   5                WakeUp_Flag = 0;
 598   5                Touch_WakeUpFlag=0;
 599   5                KeyData = 0;
 600   5              }   
 601   4            }
 602   3            
 603   3          
 604   3          }
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 11  

 605   2          else
 606   2          {
 607   3            if(++WakeUpThenScanCount>5)
 608   3            {
 609   4              WakeUpThenScanCount = 0;
 610   4              WakeUp_Flag = 0;
 611   4            }
 612   3            for(t=0;t<CurrentChannelMax;t++)
 613   3            {
 614   4              FilterDataDeal(t);
 615   4              if(!WakeUp_Flag)
 616   4              {
 617   5                
 618   5                BaseLine[t] = RawData[t]; 
 619   5              } 
 620   4            }
 621   3            
 622   3          }
 623   2          
 624   2          #endif
 625   2        }  
 626   1        
 627   1        return KeyData;
 628   1      }
 629          
 630          /**************************************************
 631          *º¯ÊýÃû³Æ£ºvoid CTK_ISR(void) interrupt 11
 632          *º¯Êý¹¦ÄÜ£º´¥ÃþÖÐ¶Ï·þÎñº¯Êý
 633          *Èë¿Ú²ÎÊý£ºvoid
 634          *³ö¿Ú²ÎÊý£ºvoid
 635          *±¸×¢  £º
 636          **************************************************/
 637          void CTK_ISR(void) interrupt  11
 638          {
 639   1         TouchKey_Service();
 640   1      }
 641          
 642          /**************************************************
 643          *º¯ÊýÃû³Æ£ºbit GetLowPowerScanFlag(void)
 644          *º¯Êý¹¦ÄÜ£d»ñÈ¡µÍ¹¦ºÄÄ£Ê½
 645          *Èë¿Ú²ÎÊý£ºvoid
 646          *³ö¿Ú²ÎÊý£ºvoid  
 647          **************************************************/
 648          bit GetLowPowerScanFlag(void)
 649          {
 650   1          #ifdef  TK_LowPowerMode
 651   1          return LowPowerScan_Flag;
 652   1          #endif
 653   1      }
 654          
 655          /**************************************************
 656          *º¯ÊýÃû³Æ£ºvoid TouchKey_LowPower_Init(unsigned char i)
 657          *º¯Êý¹¦ÄÜ£dµÍ¹¦ºÄ³õÊ¼»¯
 658          *Èë¿Ú²ÎÊý£ºvoid
 659          *³ö¿Ú²ÎÊý£ºvoid  
 660          **************************************************/
 661          unsigned  char    xdata       BaseLineAdjusttmp_Low[SOCAPI_SET_TOUCHKEY_TOTAL];
 662          unsigned  char  xdata       CurrentChannel_Low[SOCAPI_SET_TOUCHKEY_TOTAL];
 663          unsigned  int   xdata       ScanTimeTemp_Low[SOCAPI_SET_TOUCHKEY_TOTAL];
 664          int   data       SetFingerThresholdtmp_Low[SOCAPI_SET_TOUCHKEY_TOTAL];
 665          void TouchKey_LowPower_Init(void)
 666          {
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 12  

 667   1          unsigned char i;
 668   1            
 669   1          for(i=0;i<WakeUpKeyNum;i++)
 670   1          {
 671   2              WakeUpKeyValue = WakeUpKey_List[i];
 672   2              ScanTimeTemp_Low[WakeUpKeyValue] = ScanTimeTemp0*TKChannelCfg[WakeUpKeyValue][SCANTIME];
 673   2              BaseLineAdjusttmp_Low[WakeUpKeyValue] = BaseLineAdjusttmp[WakeUpKeyValue];//(TKCFG1 & 0X80) | Base
             -LineAdjusttmp[WakeUpKeyValue];
 674   2              CurrentChannel_Low[WakeUpKeyValue] =  0xc0|CurrentChannel[WakeUpKeyValue];
 675   2      
 676   2              SetFingerThresholdtmp_Low[WakeUpKeyValue] = TKChannelCfg[WakeUpKeyValue][FINGER_THRESHOLD_H]*256+T
             -KChannelCfg[WakeUpKeyValue][FINGER_THRESHOLD_L];        
 677   2      
 678   2              TKCFG0 &= 0XF0;
 679   2              TKCFG0 |= TKChannelCfg[0][SET_TOUCH_FREQ];
 680   2          }
 681   1      }
 682          
 683          /**************************************************
 684          *º¯ÊýÃû³Æ£ºvoid TouchKey_IntoLowPowerMode(void)
 685          *º¯Êý¹¦ÄÜ£d½øÈëµÍ¹¦ºÄÄ£Ê½
 686          *Èë¿Ú²ÎÊý£ºvoid
 687          *³ö¿Ú²ÎÊý£ºvoid  
 688          **************************************************/
 689          void TouchKey_IntoLowPowerMode(void)
 690          {
 691   1          #ifdef  TK_LowPowerMode
 692   1        unsigned char t;
 693   1          LowPowerScan_Flag = 1;
 694   1      
 695   1        ScanTimeTemp0 = ScanTime >> ScanTimeCon;
 696   1          Customer_IntoLowPowerMode_Init();
 697   1      
 698   1          TouchKey_LowPower_Init();
 699   1         
 700   1        for(t=0;t<CurrentChannelMax;t++)
 701   1        {
 702   2           TouchCnt[t] = 0;
 703   2        }
 704   1          #endif
 705   1      }
 706          
 707          #ifdef  TK_LowPowerMode
 708          /**************************************************
 709          *º¯ÊýÃû³Æ£ºvoid TouchKey_QuitLowPowerMode(void)
 710          *º¯Êý¹¦ÄÜ£dÍË³öµÍ¹¦ºÄÄ£Ê½
 711          *Èë¿Ú²ÎÊý£ºvoid
 712          *³ö¿Ú²ÎÊý£ºvoid  
 713          **************************************************/
 714          void TouchKey_QuitLowPowerMode(void)
 715          {
 716   1         LowPowerScan_Flag = 0;
 717   1           WakeUp_Flag = 1;
 718   1         
 719   1           TKCR = 0x80|CurrentChannel[0];
 720   1         TKTM = ScanTime*TKChannelCfg[0][SCANTIME]; 
 721   1         TRIG = 1;
 722   1         while(TRIF == 0);  
 723   1         TRIF = 0;
 724   1         TK_IE1 = TK_IE1|0x10;            //Ê¹ÄÜTKÖÐ¶Ï
 725   1           TRIG = 1; 
 726   1           Customer_QuitLowPowerMode_Init();
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 13  

 727   1      }
 728          
 729          
 730          /**************************************************
 731          *º¯ÊýÃû³Æ£ºvoid Lowpower_BaselineUpdate(unsigned char i)
 732          *º¯Êý¹¦ÄÜ£dµÍ¹¦ºÄ»ùÏß¸üÐÂ
 733          *Èë¿Ú²ÎÊý£ºunsigned char
 734          *³ö¿Ú²ÎÊý£ºvoid  
 735          **************************************************/
 736          void Lowpower_BaselineUpdate(unsigned char i)
 737          {
 738   1        BaseLine[WakeUpKeyValue] =BaseLine[WakeUpKeyValue]-(BaseLine[WakeUpKeyValue]>>i)+(RawData[WakeUpKeyValue]
             ->>i);
 739   1      }
 740          
 741          
 742          /**************************************************
 743          *º¯ÊýÃû³Æ£ºvoid TouchKey_LowPower_Dispose(void)
 744          *º¯Êý¹¦ÄÜ£dµÍ¹¦ºÄÉ¨ÃèÊý¾Ý´¦Àí
 745          *Èë¿Ú²ÎÊý£ºvoid
 746          *³ö¿Ú²ÎÊý£ºvoid  
 747          **************************************************/
 748          
 749          void TouchKey_LowPower_Dispose(void)
 750          {  
 751   1        int data differData; 
 752   1      
 753   1        unsigned char data WakeUpKey_Index;
 754   1      
 755   1        
 756   1        BTM_WakeUpFlag = 0;
 757   1      
 758   1          TRIG = 1;
 759   1          PCON = 0x02;  //PCONµÄbit1 STOPÎ»Ð´1£¬ÅäÖÃMCU½øÈëSTOPÄ£Ê½
 760   1          _nop_();    //ÖÁÉÙÐèÒª8¸ö_nop_()
 761   1          _nop_();
 762   1          _nop_();
 763   1          _nop_();
 764   1          _nop_();
 765   1          _nop_();
 766   1          _nop_();
 767   1          _nop_();
 768   1      
 769   1          TRIG = 1;
 770   1          PCON = 0x02;  //PCONµÄbit1 STOPÎ»Ð´1£¬ÅäÖÃMCU½øÈëSTOPÄ£Ê½
 771   1          _nop_();    //ÖÁÉÙÐèÒª8¸ö_nop_()
 772   1          _nop_();
 773   1          _nop_();
 774   1          _nop_();
 775   1          _nop_();
 776   1          _nop_();
 777   1          _nop_();
 778   1          _nop_();
 779   1        
 780   1        for(WakeUpKey_Index=0; WakeUpKey_Index<WakeUpKeyNum; WakeUpKey_Index++) //Ñ­»·É¨Ãè°´¼ü
 781   1        {
 782   2      
 783   2      
 784   2              WakeUpKeyValue = WakeUpKey_List[WakeUpKey_Index];
 785   2          TKCFG1 =  BaseLineAdjusttmp_Low[WakeUpKeyValue]; 
 786   2          TKTM = ScanTimeTemp_Low[WakeUpKeyValue];//ScanTimeTemp;
 787   2          TKCR = CurrentChannel_Low[WakeUpKeyValue];
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 14  

 788   2      
 789   2              PCON = 0x02;  //PCONµÄbit1 STOPÎ»Ð´1£¬ÅäÖÃMCU½øÈëSTOPÄ£Ê½
 790   2            _nop_();    //ÖÁÉÙÐèÒª8¸ö_nop_()
 791   2              _nop_();
 792   2              _nop_();
 793   2              _nop_();
 794   2              _nop_();
 795   2              _nop_();
 796   2              _nop_();
 797   2            _nop_();       
 798   2      
 799   2              differData = (TKCNT<<ScanTimeCon)-BaseLine[WakeUpKeyValue] ; 
 800   2        
 801   2          if(differData >= SetFingerThresholdtmp_Low[WakeUpKeyValue])
 802   2            {
 803   3             SingleKeyFastScan_Flag = 1;
 804   3             break;       
 805   3            } 
 806   2            
 807   2            
 808   2            else if(differData > (-(SetFingerThresholdtmp_Low[WakeUpKeyValue]>>2)))
 809   2            {
 810   3               if(WakeUpNum==WakeUpKey_Index)
 811   3                BaseLine[WakeUpKeyValue] += differData>>4;
 812   3             }
 813   2            else  
 814   2            {
 815   3                BaseLine[WakeUpKeyValue] += differData>>2;
 816   3            } 
 817   2            
 818   2            
 819   2        }
 820   1      
 821   1      
 822   1        if(++WakeUpNum>=BaselineUpdateCnt)
 823   1        {
 824   2          WakeUpNum = 0;
 825   2        }
 826   1        
 827   1      
 828   1      }
 829          
 830          /**************************************************
 831          *º¯ÊýÃû³Æ£ºvoid SingleKeyFastScan(void)
 832          *º¯Êý¹¦ÄÜ£dµ¥°´¼ü¿ìËÙÉ¨ÃèÄ£Ê½
 833          *Èë¿Ú²ÎÊý£ºvoid
 834          *³ö¿Ú²ÎÊý£ºvoid  
 835          **************************************************/
 836          void SingleKeyFastScan(void)
 837          { 
 838   1        unsigned char i;
 839   1        int differData; 
 840   1        int SetFingerThresholdtmp;
 841   1        
 842   1        SingleKeyFastScan_Flag = 0;
 843   1        TK_IE1 = TK_IE1|0x10; //´ò¿ªTKÖÐ¶Ï
 844   1        TKCFG1 = (TKCFG1 & 0X80) | BaseLineAdjusttmp[WakeUpKeyValue];
 845   1        TKCR = 0x80|CurrentChannel[WakeUpKeyValue]; 
 846   1        TKTM = ScanTimeTemp0*TKChannelCfg[WakeUpKeyValue][SCANTIME];
 847   1        
 848   1        for(i=0;i<TK_WakeUpConfirmTouchCnt;i++)      //
 849   1          {        
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 15  

 850   2        
 851   2           TRIG = 1;
 852   2           TKSleepMode();
 853   2           RawData[WakeUpKeyValue] = TKCNT << ScanTimeCon;
 854   2           FilterDataDeal(WakeUpKeyValue);
 855   2               differData = RawData[WakeUpKeyValue]-BaseLine[WakeUpKeyValue] ;
 856   2           SetFingerThresholdtmp = GetCurrFingerValue(WakeUpKeyValue);
 857   2      
 858   2           if(differData >= SetFingerThresholdtmp)
 859   2               {   
 860   3                  TouchCnt[WakeUpKeyValue]++;  
 861   3               }             
 862   2               else
 863   2           {
 864   3            break;
 865   3           }
 866   2          }
 867   1        
 868   1          if(TouchCnt[WakeUpKeyValue]>=TK_WakeUpConfirmTouchCnt)
 869   1          {    
 870   2           TouchKey_QuitLowPowerMode();       
 871   2           Touch_WakeUpFlag= 1; 
 872   2        }
 873   1          else
 874   1          {
 875   2          
 876   2              TouchCnt[WakeUpKeyValue] = 0;
 877   2          
 878   2          }
 879   1      }
 880          
 881          
 882          void  TKSleepMode(void)
 883          {   
 884   1        
 885   1        PCON = 0x02;  //PCONµÄbit1 STOPÎ»Ð´1£¬ÅäÖÃMCU½øÈëSTOPÄ£Ê½
 886   1        _nop_();    //ÖÁÉÙÐèÒª8¸ö_nop_()
 887   1          _nop_();
 888   1          _nop_();
 889   1          _nop_();
 890   1          _nop_();
 891   1          _nop_();
 892   1          _nop_();
 893   1        _nop_();
 894   1      }
 895          #endif
 896          /**************************************************
 897          *º¯ÊýÃû³Æ£ºvoid LowPower_Touchkey_Scan(void)
 898          *º¯Êý¹¦ÄÜ£dµÍ¹¦ºÄÄ£Ê½TKÉ¨Ãè
 899          *Èë¿Ú²ÎÊý£ºvoid
 900          *³ö¿Ú²ÎÊý£ºvoid  
 901          **************************************************/
 902           
 903          
 904          void LowPower_Touchkey_Scan(void)
 905          {               
 906   1          #ifdef  TK_LowPowerMode 
 907   1          
 908   1          TKCR &= 0x7f;//~0x80;
 909   1          PCON = 0x02;  //PCONµÄbit1 STOPÎ»Ð´1£¬ÅäÖÃMCU½øÈëSTOPÄ£Ê½
 910   1          _nop_();    //ÖÁÉÙÐèÒª8¸ö_nop_()
 911   1          _nop_();
C51 COMPILER V9.60.0.0   TKDRIVER                                                          01/06/2023 09:30:59 PAGE 16  

 912   1          _nop_();
 913   1          _nop_();
 914   1          _nop_();
 915   1          _nop_();
 916   1          _nop_();
 917   1          _nop_();
 918   1          TKCR |= 0x80; //´ò¿ªTKµçÔ´
 919   1      
 920   1        //½øÐÐ°´¼ü´¦Àí
 921   1        if(BTM_WakeUpFlag)
 922   1        {
 923   2      
 924   2          TouchKey_LowPower_Dispose();       //¼ì²â°´¼ü 
 925   2          
 926   2          if( SingleKeyFastScan_Flag == 1)
 927   2            {                  
 928   3              SingleKeyFastScan();       //ÈôÓÐ°´¼üÐÅÏ¢½øÈëµ¥°´¼ü¿ìËÙ¶à´ÎÉ¨ÃèÈ·¶¨°´¼üÊÇ·ñÕæÊµÐÅºÅ¡£
 929   3            }
 930   2        
 931   2          // ÓÃ»§BTM»½ÐÑºóµÄ´¦Àíº¯Êý
 932   2            Customer_BTM_Dispose();
 933   2              
 934   2            Time_Process();
 935   2      //      ADC_Process();             //²âÊÔÓÃ7.12
 936   2            SleepLED_Process();
 937   2            WakeAutoSleep();
 938   2      //      Key_Scan();
 939   2            
 940   2          //  P31=0;  ;       //·ÇBTM»½ÐÑ£¬ÓÃ»§¸ù¾ÝÐèÒª×ÔÐÐÔöÌí´¦Àí³ÌÐò
 941   2          }
 942   1        else
 943   1        {
 944   2          //  P31=~P31;   ;       //·ÇBTM»½ÐÑ£¬ÓÃ»§¸ù¾ÝÐèÒª×ÔÐÐÔöÌí´¦Àí³ÌÐò
 945   2          //LowPowerScan_Flag = 0;
 946   2          
 947   2          TouchKey_QuitLowPowerMode();
 948   2          
 949   2        }
 950   1        #endif    
 951   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2449    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =     58      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
