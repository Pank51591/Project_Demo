# IEEE 802.3 标准中规定的 CRC32 算法



### 示例代码

```c
#include <stdio.h>
#include <stdint.h>

// 多项式除数 0xEDB88320
#define POLY 0xEDB88320UL

// 计算 CRC32 校验和
uint32_t crc32(const void *data, size_t len)
{
    const uint8_t *bytes = data;
    uint32_t crc = 0xFFFFFFFFUL;

    // 循环处理每个字节
    for (size_t i = 0; i < len; i++) 
    {
    	crc ^= bytes[i];        // 把当前字节与 crc 的低 8 位进行异或操作

        // 处理当前字节的 8 位，每次处理一位
        for (int j = 0; j < 8; j++)
        {
            if (crc & 1) {      // 如果 crc 的最低位为 1，则右移并与多项式除数进行异或操作            		
                crc = (crc >> 1) ^ POLY;
                } else {            // 否则，只右移一个比特位
              crc >>= 1;
           }
        }
	}

return ~crc;                // 取反操作得到最终结果

}

int main()
{
    // 测试数据
    char data[] = "123456789";
    size_t len = sizeof(data) - 1;  // 注意，字符数组中包含了一个字符串末尾的 NULL 结束符

    // 计算 CRC32 校验和
    uint32_t crc = crc32(data, len);

    // 输出结果
    printf("CRC32: 0x%08X\n", crc);

	return 0;

}
```

示例程序中，crc32 函数用于计算给定长度的数据的 CRC32 校验和。该函数接受两个参数，分别为指向待计算数据的指针和数据的长度。函数首先将多项式除数（0xEDB88320UL）赋给一个 32 位的 CRC 寄存器（变量 crc），然后对待校验数据的每个字节进行处理。对于每个字节，函数先将其与 CRC 寄存器的低 8 位进行异或操作，然后循环处理其 8 位二进制位，每次判断最低位是否为 1，如果是，则将 CRC 寄存器右移一位并与多项式除数进行异或操作，否则只将 CRC 寄存器右移一位。处理完所有字节后，函数对 CRC 寄存器进行取反操作，得到最终的 CRC32 校验和。

在主函数中，示例程序使用一个字符数组作为测试数据，然后调用 crc32 函数计算 CRC32 校验和，并输出结果。需要注意的是，字符数组中包含了一个字符串末尾的 NULL 结束符，因此在计算数据长度时需要减 1。

### IEEE 802.3 标准CRC32算法流程

IEEE 802.3 标准中规定的 CRC32 算法是一种基于多项式除法的校验和计算方法。在以太网中，每个帧都包括一个 CRC32 校验和字段，用于检测数据在传输过程中是否出现了错误。该算法使用的多项式除数为 0xEDB88320L，初始值为 0xFFFFFFFF。

具体来说，CRC32 算法首先将初始值赋给一个 32 位寄存器，然后对待校验数据的每个字节进行处理。处理过程包括以下两个步骤：

将下一个字节与当前 CRC 寄存器的低 8 位进行异或操作。
对于 CRC 寄存器中的每一位，如果其数值为 1，则将寄存器右移一位并与多项式除数进行异或操作；否则只将寄存器右移一位。
处理完所有字节后，将最终得到的 CRC 寄存器中的值进行反转和异或操作，即可得到最终的 CRC32 校验和。

更具体地说，反转和异或操作的过程如下：

将 CRC 寄存器中的每个字节按照从高到低的顺序反转（例如，原本为 0x12345678 的寄存器变成 x78563412）。
将反转后的 CRC 寄存器的值与 0xFFFFFFFF 进行异或操作。

上述过程中使用的多项式除数 0xEDB88320L 的二进制表示形式为 11101101101110001000010110000000（前导 1 略去），其中这些位的排列方式经过精心的设计，可以使其具有很好的检错性能和误差容忍度，从而广泛应用于各种网络传输、存储校验等领域。

### 为什么要用0xEDB88320L ？

0xEDB88320L 是一个常用的多项式除数，被广泛应用于各种 CRC32 算法中，包括 IEEE 802.3 标准中规定的 CRC32 算法。

使用不同的多项式除数可以得到不同的 CRC32 校验和结果。因此，在设计具体应用时，需要根据实际需求选择合适的多项式除数。不过，由于历史原因以及兼容性等考虑，0xEDB88320L 成为了 CRC32 校验算法中最为常用的多项式除数之一。

在计算 CRC32 校验和时，除数通常被作为一个核心参数嵌入到算法中。0xEDB88320L 的二进制表示形式为 11101101101110001000010110000000（前导 1 略去），其中这些位的排列方式经过精心的设计，可以使其具有很好的检错性能和误差容忍度，从而广泛应用于各种网络传输、存储校验等领域。





————————————————
版权声明：本文为CSDN博主「MrWang.」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/MrWangHao/article/details/131296293